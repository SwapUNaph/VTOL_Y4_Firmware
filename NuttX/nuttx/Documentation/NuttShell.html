<html>
<head>
<title>NuttShell</title>
</head>
<body background="backgd.gif">
<hr><hr>
<table width ="100%">
  <tr align="center" bgcolor="#e4e4e4">
    <td>
      <h1><big><font color="#3c34ec"><i>NuttShell (NSH)</i></font></big></h1>
      <p>Last Updated: August 4, 2016</p>
    </td>
  </tr>
</table>
<hr><hr>
<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
  <h1>Table of Contents</h1>
    </td>
  </tr>
</table>

<center><table width ="80%">
<tr>
<td>
<table>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#overview">1.0 Overview</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#frontend">1.1 Console/NSH Front End</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdoverview">1.2 Command Overview</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#conditional">1.3 Conditional Command Execution</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#looping">1.4 Looping</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#builtinvars">1.5 Built-In Variables</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#currentwd">1.6 Current Working Directory</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#environvars">1.7 Environment Variables</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#startupscript">1.8 NSH Start-Up Script</a>
  </td>
</tr>

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#commands">2.0 Commands</a>.
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdtest">2.1 Evaluate Expression (test)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdaddroute">2.2 Add a Routing Table Entry (addroute)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdarp">2.3 Access the ARP table (arp)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdbase64dec">2.4 Base64 Decode (base64dec)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdbase64enc">2.5 Base64 Encode (base64enc)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdbasename">2.6 Extract Base File/Directory Name (basename)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdbreak">2.7 Terminate a Loop (break)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdcat">2.8 Concatenate Files (cat)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdcd">2.9 Change Current Working Directory (cd)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdcmp">2.10 Compare Files (cmp)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdcp">2.11 Copy Files (cp)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmddate">2.12 Show or set the date and time (date)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmddd">2.13 Copy and Convert Files (dd)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmddelroute">2.14 Delete a Routing Table Entry (delroute)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmddf">2.15 Show volume status (df)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmddirname">2.16 Extract Path to a File/Directory (dirname)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdecho">2.17 Echo Strings and Variables (echo)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdexec">2.18 Execute User Code (exec)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdexit">2.19 Exit NSH (exit)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdfree">2.20 Show Memory Manager Status (free)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdget">2.21 Get File Via TFTP (get)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdhelp">2.22 Show Usage Command Usage (help)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdhexdump">2.23 Hexadecimal Dump of File or Device (hexdump)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdifconfig">2.24 Manage Network Configuration (ifconfig)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdifdown">2.25 Take a network down (ifdown)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdifup">2.26 Bring a network up (ifup)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdinsmod">2.27 Install an OS module (insmod)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdkill">2.28 Send a signal to a task (kill)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdlosetup">2.29 Setup/teardown the Loop Device (losetup)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdls">2.30 List Directory Contents (ls)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdlsmod">2.31 Show information about installed OS modules (lsmod)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdmd5">2.32 Calculate MD5 (md5)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdmbhw">2.33 Access Memory (mb, mh, and mw)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdps">2.34 Show Current Tasks and Threads (ps)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdmkdir">2.35 Create a Directory (mkdir)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdmkfatfs">2.36 Create a FAT Filesystem (mkfatfs)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdmkfifo">2.37 Create a FIFO (mkfifo)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdmkrd">2.38 Create a RAMDISK (mkrd)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdmount">2.39 Mount a File System (mount)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdmv">2.40 Rename a File (mv)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdnfsmount">2.41 Mount an NFS file system (nfsmount)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdnslookup">2.42 Lookup a network address (nslookup)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdpasswd">2.43 Change a User's Password (passwd)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdping">2.44 Check Network Peer (ping/ping6)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdpoweroff">2.45 Shut the system down (poweroff)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdput">2.46 Send File Via TFTP (put)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdpwd">2.47 Show Current Working Directory (pwd)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdreboot">2.48 Reset and reboot the system (reboot)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdrm">2.49 Remove a File (rm)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdrmdir">2.50 Remove a Directory (rmdir)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdrmmod">2.51 Remove on OS Module (rmmod)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdset">2.52 Set an Environment Variable (set)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdsh">2.53 Execute an NSH Script (sh)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdshutdown">2.54 Shut the system down (shutdown)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdsleep">2.55 Wait for Seconds (sleep)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdtime">2.56 Time execution of another command (time)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdunmount">2.57 Unmount a File System (umount)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmduname">2.58 Print system information (uname)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdunset">2.59 Unset an Environment Variable (unset)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdurldec">2.60 URL Decode (urldecode)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdurlencode">2.61 URL Encode (urlencode)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmduseradd">2.62 Add a New User (useradd)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmduserdel">2.63 Delete a user (userdel)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdusleep">2.64 Wait for Microseconds (usleep)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdwget">2.65 Get File Via HTTP (wget)</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmdxd">2.66 Hexadecimal Dump of Memory (xd)</a>
  </td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#configuration">3.0 Configuration Settings</a>
</td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#cmddependencies">3.1 Command Dependencies on Configuration Settings</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#nshconfiguration">3.2  NSH-Specific Configuration Settings</a>
  </td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#customizingnsh">4.0 Customizing the NuttShell</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#custonshlib">4.1 The NSH Library and NSH Initialization</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#custoncmds">4.2 NSH Commands</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#custapps">4.3 NSH &quot;Built-In&quot; Applications</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#custinit">4.4 Customizing NSH Initialization</a>
  </td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#nshlogin">5.0 Shell Login</a>
</td>
<tr>
  <td><br></td>
  <td>
    <a href="#enablelogin">5.1 Enabling Shell Logins</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#verifymethods">5.2 Verification of Credentials</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#passwdfiles">5.3 Password Files</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <a href="#passwdromfs">5.4 Creating a Password File for a ROMFS File System</a>
  </td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#index">Index</a>
  </td>
</tr>
</table></center>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="overview"><h1>1.0 Overview</h1></a>
  </td>
  </tr>
</table>

<p>
  <a name="nshlibrary"><b>The NSH Library</b></a>.
  The <code>apps/nshlib</code> sub-directory contains the NuttShell (NSH)
  library.
  This library can easily to linked to produce a NSH application (See as an example <code>apps/examples/nsh</code>).
  The NSH Library provides a simple shell application for NuttX.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="frontend"><h2>1.1 Console/NSH Front End</h2></a>
  </td>
  </tr>
</table>

<p>
  <a name="nshconsoles"><b>NSH Consoles</b></a>.
  Using settings in the configuration file, NSH may be configured to use
  (1) the serial stdin/out,
  (2) a USB serial device (such as CDC/ACM), or
  (3) a telnet connection as the console.
  Or, perhaps even all at once since or BOTH.
  An indefinite number of telnet sessions are supported.
</p>
<p>
  <a name="nshprompt"><b>Start-Up prompt</b></a>.
  When NSH is started, you will see the a welcome message such the following on the selected console:
  <ul><pre>
NuttShell (NSH)
nsh&gt;
</pre></ul>
  The greating may also include NuttX versioning information if you are using a versioned copy of NuttX.
  <code>nsh&gt;</code> is the NSH prompt and indicates that you may enter a command from the console.
</p>
<p>
  <a name="cle"><b>Extended Command Line Editing</b></a>.
  By default, NuttX uses a simple command line editor that allows command entry after the <code>nsh&gt;</code> and supports only the <i>backspace</i> key for editing.
  However, a more complete command line editor can be selected by setting <code>CONFIG_NSH_CLE=y</code> in the NuttX configuration file.
  When that option is selected, the following EMACS-like line editing commands are supported:
</p>
<center><table width="60%" border="5" bgcolor="f8f8f8" bordercolor="lightgray">
<tr>
  <td align="center" bgcolor="#e4e4e4">
    <b>Key Binding</b>
  </td>
  <td align="center" bgcolor="#e4e4e4">
    <b>Editor Action</b>
  </td>
</tr>
<tr>
  <td align="left" valign="top">
    <code>^A</code>
  </td>
  <td align="left" valign="top">
     Move cursor to start of the line
  </td>
</tr>
<tr>
  <td align="left" valign="top">
    <code>^B</code>
  </td>
  <td align="left" valign="top">
    Move left one character
  </td>
</tr>
<tr>
  <td align="left" valign="top">
    <code>^D</code> or <i>Del</i>
  </td>
  <td align="left" valign="top">
    Delete a single character at the cursor position
  </td>
</tr>
<tr>
  <td align="left" valign="top">
    <code>^E</code>
  </td>
  <td align="left" valign="top">
    Move cursor to end of current line
  </td>
</tr>
<tr>
  <td align="left" valign="top">
    <code>^F</code>
  </td>
  <td align="left" valign="top">
    Move right one character
  </td>
</tr>
<tr>
  <td align="left" valign="top">
    <code>^H</code> or <i>Backspace</i>
  </td>
  <td align="left" valign="top">
    Delete character, left (backspace)
  </td>
</tr>
<tr>
  <td align="left" valign="top">
    <code>^K</code>
  </td>
  <td align="left" valign="top">
    Delete to the end of the line
  </td>
</tr>
<tr>
  <td align="left" valign="top">
    <code>^U</code>
  </td>
  <td align="left" valign="top">
    Delete the entire line
  </td>
</tr>
</table></center>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdoverview"><h2>1.2 Command Overview</h2></a>
  </td>
  </tr>
</table>

<p>
  <b>Simple, Re-directed, and Background Commands</b>.
  The NuttShell (NSH) is a simple shell application.
  NSH supports the following commands forms:
</p>
<ul><table>
  <tr>
     <td>Simple command:</td>
     <td><code>&lt;cmd&gt;</code></td>
  </tr>
  <tr>
     <td>Command with re-directed output:</td>
     <td><code>
         &lt;cmd&gt; &gt; &lt;file&gt;<br>
         &lt;cmd&gt; &gt;&gt; &lt;file&gt;
     </code></td>
  </tr>
  <tr>
     <td>Background command:</td>
     <td><code>&lt;cmd&gt; &amp;</code></td>
  </tr>
  <tr>
     <td>Re-directed background command:</td>
     <td><code>
       &lt;cmd&gt; &gt; &lt;file&gt; &amp;<br>
       &lt;cmd&gt; &gt;&gt; &lt;file&gt; &amp;
     </code></td>
  </tr>
</table></ul>
<p>Where:</p>
<ul><table>
  <tr>
    <td><code>&lt;cmd&gt;</code></td>
    <td>
      is any one of the simple commands listed later.
    </td>
  </tr>
  <tr>
    <td><code>&lt;file&gt;</code></td>
    <td>
      is the full or relative path to any writable object
      in the filesystem name space (file or character driver).
      Such objects will be referred to simply as files throughout
      this document.
    </td>
  </tr>
</table></ul>
<p>
  <b><big><code>nice</code></big>'d Background Commands</b>
  NSH executes at the mid-priority (128).  Backgrounded commands can
  be made to execute at higher or lower priorities using <code>nice</code>:
</p>
<ul><code>
  [nice [-d &lt;niceness&gt;&gt;]] &lt;cmd&gt; [&gt; &lt;file&gt;|&gt;&gt; &lt;file&gt;] [&amp;]
</code></ul>
<p>
  Where <code>&lt;niceness&gt;</code> is any value between -20 and 19 where lower
  (more negative values) correspond to higher priorities.
  The default niceness is 10.
</p>

<p>
  <b>Multiple commands per line</b>.
  NSH will accept multiple commands per command line with each command separated with the semi-colon character (;).
</p>

<p>
   <b>Optional Syntax Extensions</b>
   Because these features commit significant resources, it is disabled by default.
</p>
<ul>
<li>
  <b><code>CONFIG_NSH_CMDPARMS</code></b>.
   If selected, then the output from commands, from file applications, and from NSH built-in commands can be used as arguments to other commands.
   The entity to be executed is identified by enclosing the command line in back quotes.
   For example,
<p>
<ul><pre>
set FOO `myprogram $BAR`
</pre></ul>
<p>
   Will execute the program named <code>myprogram</code> passing it the value of the environment variable <code>BAR</code>.
   The value of the environment variable <code>FOO</code> is then set output of <code>myprogram</code> on <code>stdout</code>.
</li>
<li>
  <b><code>CONFIG_NSH_ARGCAT</code></b>.
  Support concatenation of strings with environment variables or command output.  For example:
  <ul><pre>
set FOO XYZ
set BAR 123
set FOOBAR ABC_${FOO}_${BAR}
</pre></ul>
  would set the environment variable <code>FOO</code> to <code>XYZ</code>, <code>BAR</code> to <code>123</code> and <code>FOOBAR</code> to <code>ABC_XYZ_123</code>.
  If <code>CONFIG_NSH_ARGCAT</code> is not selected, then a slightly small FLASH footprint results but then also only simple environment variables like <code>$FOO</code> can be used on the command line.
</li>
</ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="conditional"><h2>1.3 Conditional Command Execution</h2></a>
  </td>
  </tr>
</table>

<p>
  An <code>if-then[-else]-fi</code> construct is also supported in order to
  support conditional execution of commands.  This works from the
  command line but is primarily intended for use within NSH scripts
  (see the <a href="#cmdsh"><code>sh</code></a> commnd).  The syntax is as follows:
</p>
<ul><pre>
if &lt;cmd&gt;
then
  [sequence of &lt;cmd&gt;]
else
  [sequence of &lt;cmd&gt;]
fi
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="looping"><h2>1.4 Looping</h2></a>
  </td>
  </tr>
</table>

<p><b>Looping Constructs</b>.
  <code>while-do-done</code> and <code>until-do-done</code> looping constructs are also supported.
  These work from the command line but are primarily intended for use within NSH scripts
  (see the <a href="#cmdsh"><code>sh</code></a> command).
</p>
<ul>
  <li>
    <p><b><code>while-do-done</code></b>.
    Execute <code>[sequence of &lt;cmd&gt;]</code> as long as <code>&lt;cmd&gt;</code> has an exit status of zero.
    The syntax is as follows:
    <ul><pre>
while &lt;cmd&gt;
do
  [sequence of &lt;cmd&gt;]
done
</pre></ul>
    </p>
  </li>
  <li>
    <p><b><code>until-do-done</code></b>
    Execute <code>[sequence of &lt;cmd&gt;]</code> as long as <code>&lt;cmd&gt;</code> has a non-zero exit status.
    The syntax is as follows:
    <ul><pre>
until &lt;cmd&gt;
do
  [sequence of &lt;cmd&gt;]
done
</pre></ul>
    </p>
  </li>
</ul>

<p><b>The <a href="#cmdbreak"><code>break</code></a> Command</b>.
  A <a href="#cmdbreak"><code>break</code></a> command is also supported.
  The <code>break</code> command is only meaningful within the body of the a while or until loop, between the <code>do</code> and <code>done</code> tokens.
  If the <code>break</code> command is executed within the body of a loop, the loop will immediately terminate and execution will continue with the next command immediately following the <code>done</code> token.
<p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="builtinvars"><h2>1.5 Built-In Variables</h2></a>
  </td>
  </tr>
</table>

<ul><table>
  <tr>
    <td valign="top"><b><code>$?</code></b></td>
    <td>
      The result of the last simple command execution.
      On backgrounded commands, this variable holds only the result of spawning the background command.
    </td>
  </tr>
</table></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="currentwd"><h2>1.6 Current Working Directory</h2></a>
  </td>
  </tr>
</table>

<p>
  <b><code>cd</code> and <code>pwd</code></b>.
  All path arguments to commands may be either an absolute path or a
  path relative to the current working directory.  The current working
  directory is set using the <a href="#cmdcd"><code>cd</code></a> command and can be queried either
  by using the <a href="#cmdpwd"><code>pwd</code></a> command or by
  using the <a href="#cmdecho"><code>echo</code></a> <a href="#environvars"><code>$PWD</code></a>
  command.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="environvars"><h2>1.7 Environment Variables</h2></a>
  </td>
  </tr>
</table>

<p>
  <b>Environment Variables:</b>
</p>
<ul><table>
  <tr>
    <td><b><code>PWD</code></b></td><td>The current working directory</td>
  </tr>
  <tr>
    <td><b><code>OLDPWD</code></b></td><td>The previous working directory</td>
  </tr>
</table></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="startupscript"><h2>1.8 NSH Start-Up Script</h2></a>
  </td>
  </tr>
</table>

<p>
  <b>NSH Start-Up Script</b>.
  NSH supports options to provide a start up script for NSH.  In general
  this capability is enabled with <code>CONFIG_NSH_ROMFSETC</code>, but has
  several other related configuration options as described with the
  <a href="#nshconfiguration">NSH-specific configuration settings</a>.
  This capability also depends on:
  <ul>
    <li><code>CONFIG_DISABLE_MOUNTPOINT</code> not set
    <li><code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 4
    <li><code>CONFIG_FS_ROMFS</code> enabled
  </ul>
</p>

<p>
  <b>Default Start-Up Behavior</b>.
  The implementation that is provided is intended to provide great flexibility
  for the use of Start-Up files.  This paragraph will discuss the general
  behavior when all of the configuration options are set to the default
  values.
</p>
<p>
  In this default case, enabling <code>CONFIG_NSH_ROMFSETC</code> will cause
  NSH to behave as follows at NSH startup time:
  <ul>
    <li>
      NSH will create a read-only RAM disk (a ROM disk), containing a tiny
      ROMFS filesystem containing the following:
<ul><pre>
`--init.d/
     `-- rcS
</pre></ul>
      Where rcS is the NSH start-up script.
    </li>
    <li>
      NSH will then mount the ROMFS filesystem at <code>/etc</code>, resulting in:
<ul><pre>
|--dev/
|   `-- ram0
`--etc/
    `--init.d/
        `-- rcS
</pre></ul>
    </li>
    <li>
      By default, the contents of rcS script are:
<ul><pre>
# Create a RAMDISK and mount it at XXXRDMOUNTPOINTXXX

mkrd -m 1 -s 512 1024
mkfatfs /dev/ram1
mount -t vfat /dev/ram1 /tmp
</pre></ul>
    </li>
    <li>
      NSH will execute the script at <code>/etc/init.d/rcS</code> at start-up (before the
      first NSH prompt.  After execution of the script, the root FS will look
      like:
<ul><pre>
|--dev/
|   |-- ram0
|   `-- ram1
|--etc/
|   `--init.d/
|       `-- rcS
`--tmp/
</pre></ul>
    </li>
  </ul>
</p>
<p>
  <b>Modifying the ROMFS Image</b>.
  The contents of the <code>/etc</code> directory are retained in the file <code>apps/nshlib/nsh_romfsimg.h</code> OR, if <code>CONFIG_NSH_ARCHROMFS</code> is defined, <code>include/arch/board/rcs.template</code>).
  In order to modify the start-up behavior, there are three things to study:
  <ol>
    <li>
      <b>Configuration Options.</b>
      The additional <code>CONFIG_NSH_ROMFSETC</code> configuration options
      discussed with the other <a href="#nshconfiguration">NSH-specific configuration settings</a>.
    </li>
    <li>
      <p>
        <b><code>tools/mkromfsimg.sh</code> Script</b>.
        The script <code>tools/mkromfsimg.sh</code> creates <code>nsh_romfsimg.h</code>.
        It is not automatically executed.  If you want to change the
        configuration settings associated with creating and mounting
        the <code>/tmp</code> directory, then it will be necessary to re-generate
        this header file using the <code>tools/mkromfsimg.sh</code> script.
      </p>
      <p>
        The behavior of this script depends upon three things:
        <ul>
          <li>The configuration settings then installed configuration.
          <li>The <code>genromfs</code> tool (available from <a href="http://romfs.sourceforge.net">http://romfs.sourceforge.net</a>).
          <li>The file <code>apps/nshlib/rcS.template</code>
          (OR, if <code>CONFIG_NSH_ARCHROMFS</code> is defined <code>include/arch/board/rcs.template</code>.
        </ul>
      </p>
    </li>
    <li>
      <b><code>rcS.template</code></b>.
      The file <code>apps/nshlib/rcS.template</code> contains the general form
      of the <code>rcS</code> file; configured values are plugged into this
      template file to produce the final <code>rcS</code> file.
    </li>
  </ol>
</p>
<p>
  <b>NOTE</b>:
  <code>apps/nshlib/rcS.template</code> generates the standard, default <code>nsh_romfsimg.h</code> file.
  If <code>CONFIG_NSH_ARCHROMFS</code> is defined in the NuttX configuration file, then a custom, board-specific <code>nsh_romfsimg.h</code> file residing in <code>configs/&lt;board&gt;/include</code> will be used.
  NOTE when the OS is configured, <code>include/arch/board</code> will be linked to <code>configs/&lt;board&gt;/include</code>.
</p>
<p>
  All of the startup-behavior is contained in <code>rcS.template</code>.  The
  role of <code>mkromfsimg.sh</code> is to (1) apply the specific configuration
  settings to <code>rcS.template</code> to create the final <code>rcS</code>, and (2) to
  generate the header file <code>nsh_romfsimg.h</code> containg the ROMFS
  file system image.
</p>

<p>
  <b>Further Information</b>.
  See the section on <a href="#customizingnsh">Customizing the NuttShell</a> for additional, more detailed information about the NSH start-up script and how to modify it.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="commands"><h1>2.0 Commands</h1></a>
  </td>
  </tr>
</table>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdtest"><h2>2.1 Evaluate Expression (test)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
[ &lt;expression&gt; ]
test &lt;expression&gt;
</pre></ul>
<p>
   <b>Synopsis</b>.
   These are two alternative forms of the same command.  They support
   evaluation of a boolean expression which sets <a href="#builtinvars"><code>$?</code></a>.
   This command is used most frequently as the conditional command following the
   <code>if</code> in the <a href="#conditional"><code>if-then[-else]-fi</code></a> construct.
</p>
<p><b>Expression Syntax:</b></p>
<ul>
  <p>
     expression = simple-expression | !expression | expression -o expression | expression -a expression
  </p>
  <p>
     simple-expression = unary-expression | binary-expression
  </p>
  <p>
     unary-expression = string-unary | file-unary
  </p>
  <p>
     string-unary = -n string | -z string
  </p>
  <p>
     file-unary = -b file | -c file | -d file | -e file | -f file | -r file | -s file | -w file
  </p>
  <p>
     binary-expression = string-binary | numeric-binary
  </p>
  <p>
     string-binary = string = string | string == string | string != string
  </p>
  <p>
     numeric-binary = integer -eq integer | integer -ge integer | integer -gt integer | integer -le integer |
                      integer -lt integer | integer -ne integer
  </p>
</ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdaddroute"><h2>2.2 Add a Routing Table Entry (addroute)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
addroute &lt;target&gt; &lt;netmask&gt; &lt;router&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  This command adds an entry in the routing table.
  The new entry will map the IP address of a router on a local network(&lt;router&gt;) to an external network characterized by the &lt;target&gt; IP address and a network mask &lt;netmask&gt;
</p>
<p>
  <b>Example:</b>
</p>
<ul><pre>
nsh&gt; addroute 1.1.1.1 2.2.2.2 3.3.3.3
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdarp"><h2>2.3 Access the ARP table (arp)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
arp [-a &lt;ipaddr&gt; |-d &lt;ipaddr&gt; |-s &lt;ipaddr&gt; &lt;hwaddr&gt;]
</pre></ul>
<p>
  <b>Synopsis</b>.
  Access the OS ARP table.
</p>
<ul><dl>
  <dt>-a &lt;ipaddr&gt;
     <dd>Will show the hardware address that the IP address &lt;ipaddr&gt; is mapped to.

  <dt>-d &lt;ipaddr&gt;
     <dd>Will delete the mapping for the IP address &lt;ipaddr&gt; from the ARP table.

  <dt>-s &lt;ipaddr&gt; &lt;hwaddr&gt;
     <dd>Will set (or replace) the mapping of the IP address &lt;ipaddr&gt; to the hardware address &lt;hwaddr&gt;.
</dl></ul>
<p>
  <b>Example:</b>
</p>
<ul><pre>
nsh&gt; arp -a 10.0.0.1
nsh: arp: no such ARP entry: 10.0.0.1

nsh&gt; arp -s 10.0.0.1 00:13:3b:12:73:e6
nsh&gt; arp -a 10.0.0.1
HWAddr: 00:13:3b:12:73:e6

nsh&gt; arp -d 10.0.0.1
nsh&gt; arp -a 10.0.0.1
nsh: arp: no such ARP entry: 10.0.0.1
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdbase64dec"><h2>2.4 Base64 Decode (base64dec)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
base64dec [-w] [-f] &lt;string or filepath&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  <i>To be provided.</i>
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdbase64enc"><h2>2.5 Base64 Encode (base64enc)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
base64enc [-w] [-f] &lt;string or filepath&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  <i>To be provided.</i>
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdbasename"><h2>2.6 Extract Base File/Directory Name (basename)</h2></a>
  </td>
  </tr>
</table>
<p><b>Command Syntax:</b></p>
<ul><pre>
basename &lt;path&gt [&lt;suffix&gt;]
</pre></ul>
<p>
  <b>Synopsis</b>.
  Extract the final string from a <code>&lt;path&gt;</code> by removing the preceding path
  segments and (optionally) removing any trailing <code>&lt;suffix&gt;</code>.
<p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdbreak"><h2>2.7 Terminate a Loop (break)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
break
</pre></ul>
<p>
  <b>Synopsis</b>.
  The <code>break</code> command is only meaningful within the body of the a <a href="#looping">while</a> or <a href="#looping">until</a> loop, between the <code>do</code> and <code>done</code> tokens.
  Outside of a loop, <code>break</code> command does nothing.
  If the <code>break</code> command is executed within the body of a loop, the loop will immediately terminate and execution will continue with the next command immediately following the <code>done</code> token.
<p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdcat"><h2>2.8 Concatenate Files (cat)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
cat <code>&lt;path&gt;</code> [<code>&lt;path&gt;</code> [<code>&lt;path&gt;</code> ...]]
</pre></ul>
<p>
  <b>Synopsis</b>.
  This command copies and concatentates all of the files at <code>&lt;path&gt;</code>
  to the console (or to another file if the output is redirected).
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdcd"><h2>2.9 Change Current Working Directory (cd)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
cd [&lt;dir-path&gt;|-|~|..]
</pre></ul>
<p>
  <b>Synopsis</b>.
  Changes the current working directory (<code>PWD</code>).  Also sets the
  previous working directory environment variable (<code>OLDPWD</code>).
<p>
<p><b>Forms:</b></p>
<ul><table>
  <tr>
    <td><b><code>cd &lt;dir-path&gt;</code></b></td>
    <td>sets the current working directory to <code>&lt;dir-path&gt;</code>.</td>
  </tr>
  <tr>
    <td><b><code>cd -</code></b></td>
    <td>sets the current working directory to the previous
       working directory ($<a href="#environvars"><code>OLDPWD</code></a>).
      Equivalent to <code><a href="#cmdcd">cd</a> $<a href="#environvars">OLDPWD</a></code>.</td>
  </tr>
  <tr>
    <td><b><code>cd</code> or <b><code>cd ~</code></b></td>
    <td>set the current working directory to the 'home'
       directory.  The <i>home</i> directory can be configured by setting
       <code>CONFIG_LIB_HOMEDIR</code> in the configuration file.  The default
       <i>home</i> directory is <code>/</code>.</td>
  </tr>
  <tr>
    <td><b><code>cd ..</code></td>
    <td>sets the current working directory to the parent directory.</td>
  </tr>
</table></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdcmp"><h2>2.10 Compare Files (cmp)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
cmp &lt;path1&gt; &lt;path2&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Compare of the contents of the file at <code>&lt;path1&gt;</code> with the contents of the file at <code>&lt;path2&gt;</code>.  Returns an indication only if the files differ.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdcp"><h2>2.11 Copy Files (cp)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
cp &lt;source-path&gt; &lt;dest-path&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Copy of the contents of the file at <code>&lt;source-path&gt;</code> to the location
  in the filesystem indicated by <code>&lt;dest-path&gt;</code>.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmddate"><h2>2.12 Show or set the date and time (date)</h2></a>
  </td>
  </tr>
</table>
<p><b>Command Syntax:</b></p>
<ul><pre>
date [-s &quot;MMM DD HH:MM:SS YYYY&quot;]
</pre></ul>
<p>
  <b>Synopsis</b>.
  Show or set the current date and time.
</p>
<p>
  Only one format is used both on display and when setting the date/time:
  <code>MMM DD HH:MM:SS YYYY</code>.  For example,
<ul><pre>
data -s &quot;Sep 1 11:30:00 2011&quot;
</pre></ul>
</p>
<p>
  24-hour time is used.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmddd"><h2>2.13 Copy and Convert Files (dd)</h2></a>
  </td>
  </tr>
</table>
<p><b>Command Syntax:</b></p>
<ul><pre>
dd if=&lt;infile&gt; of=&lt;outfile&gt; [bs=&lt;sectsize&gt;] [count=&lt;sectors&gt;] [skip=&lt;sectors&gt;]
</pre></ul>
<p>
  <b>Synopsis</b>.
  Copy blocks from &lt;infile&gt; to &lt;outfile&gt;.
  &lt;infile&gt; or &lt;outfile&gt; may be the path to a standard file, a character device, or a block device.
  Examples follow:
</p>
<ol>
  <li>
    Read from character device, write to regular file.
    This will create a new file of the specified size filled with zero.
<ul><pre>
nsh&gt; ls -l /dev
/dev:
 crw-rw-rw-       0 zero
nsh&gt; dd if=/dev/zero of=/tmp/zeros bs=64 count=16
nsh&gt; ls -l /tmp
/tmp:
 -rw-rw-rw-    1024 ZEROS
</pre></ul>
  </li>
  <li>
    Read from character device, write to block device.
    This will fill the entire block device with zeros.
  </li>
<ul><pre>
nsh&gt; ls -l /dev
/dev:
 brw-rw-rw-       0 ram0
 crw-rw-rw-       0 zero
nsh&gt; dd if=/dev/zero of=/dev/ram0
</pre></ul>
  </li>
  <li>
    Read from a block devic, write to a character device.  This
    will read the entire block device and dump the contents in
    the bit bucket.
  </li>
<ul><pre>
nsh&gt; ls -l /dev
/dev:
 crw-rw-rw-       0 null
 brw-rw-rw-       0 ram0
nsh&gt; dd if=/dev/ram0 of=/dev/null
</pre></ul>
  </li>
</ol>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmddelroute"><h2>2.14 Delete a Routing Table Entry (delroute)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
delroute &lt;target&gt; &lt;netmask&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  The entry removed will be the first entry in the routing table that matches
  the external network characterized by the &lt;target&gt; IP address and the network mask &lt;netmask&gt;
<p>
  <b>Example:</b>
</p>
<ul><pre>
nsh&gt; delroute 1.1.1.1 2.2.2.2
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmddf"><h2>2.15 Show Volume Status (df)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
df [-h]
</pre></ul>
<p>
  <b>Synopsis</b>.
    Show the state of each mounted volume.
    As an example:
</p>
<ul><pre>
nsh&gt; mount
  /etc type romfs
  /tmp type vfat
nsh&gt; df
  Block  Number
  Size   Blocks     Used Available Mounted on
    64        6        6         0 /etc
   512      985        2       983 /tmp
nsh&gt;
</pre></ul>
<p>
  If <code>CONFIG_NSH_CMDOPT_DF_H</code> is defined in the NuttX configuration, then the <code>df</code> will also support an option <code>-h</code> which may be used to show the volume information in <i>human readable</i> format.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmddirname"><h2>2.16 Extract Path to a File/Directory (dirname)</h2></a>
  </td>
  </tr>
</table>
<p><b>Command Syntax:</b></p>
<ul><pre>
dirname &lt;path&gt
</pre></ul>
<p>
  <b>Synopsis</b>.
  Extract the path string leading up to the full  <code>&lt;path&gt;</code> by removing
  the final directory or file name.
<p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdecho"><h2>2.17 Echo Strings and Variables (echo)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
echo [&lt;string|$name&gt; [&lt;string|$name&gt;...]]
</pre></ul>
<p>
  <b>Synopsis</b>.
  Copy the sequence of strings and expanded environment variables to
  console output (or to a file if the output is re-directed).
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdexec"><h2>2.18 Execute User Code (exec)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
exec &lt;hex-address&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Execute the user logic at address <code>&lt;hex-address&gt;</code>.  NSH will pause
  until the execution unless the user logic is executed in background
  via <code><a href="#cmdexec">exec</a> &lt;hex-address&gt; &amp;</code>.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdexit"><h2>2.19 Exit NSH (exit)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
exit
</pre></ul>
<p>
  <b>Synopsis</b>.
  Exit NSH.  Only useful for the serial front end if you have started some other tasks (perhaps
  using the <code><a href="#cmdexec">exec</a></code> command) and you would like to have NSH out of the
  way.  For the telnet front-end, <code>exit</code> terminates the telenet session.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdfree"><h2>2.20 Show Memory Manager Status (free)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
free
</pre></ul>
<p>
  <b>Synopsis</b>.
  Show the current state of the memory allocator.  For example,
</p>
<ul><pre>
nsh&gt; free
             total       used       free    largest
Mem:       4194288    1591552    2602736    2601584
nsh&gt;
</pre></ul>
<p><b>Where:</b></p>
<ul><table>
  <tr>
    <td><b><code>total</code></b></td>
    <td>This is the total size of memory allocated for use by malloc in bytes.</td>
  </tr>
  <tr>
    <td><b><code>used</code></b></td>
    <td>This is the total size of memory occupied by chunks handed out by malloc.</td>
  </tr>
  <tr>
    <td><b><code>free</code></b></td>
    <td>This is the total size of memory occupied by free (not in use) chunks.</td>
  </tr>
  <tr>
    <td><b><code>largest</code></b></td>
    <td>Size of the largest free (not in use) chunk.</td>
  </tr>
</table></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdget"><h2>2.21 Get File Via TFTP (get)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
get [-b|-n] [-f &lt;local-path&gt;] -h &lt;ip-address&gt; &lt;remote-path&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Copy the file at <code>&lt;remote-address&gt;</code> from the host whose IP address is
  identified by <code>&lt;ip-address&gt;</code>.
</p>
<p><b>Other options:</b></p>
<ul><table>
  <tr>
    <td><b><code>-f &lt;local-path&gt;</code></b></td>
    <td>
      The file will be saved relative to the current working directory
      unless <code>&lt;local-path&gt;</code> is provided.
    </td>
  </tr>
  <tr>
    <td><b><code>-b|-n</code></b></td>
    <td>
      Selects either binary (&quot;octet&quot;) or test (&quot;netascii&quot;) transfer
      mode.  Default: text.
    </td>
  </tr>
</table></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdhelp"><h2>2.22 Show Usage Command Usage (help)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
help [-v] [&lt;cmd&gt;]
</pre></ul>
<p>
  <b>Synopsis</b>.
  Presents summary information about NSH commands to console.
</p>
<p><b>Options:</b></p>
<ul><table>
  <tr>
    <td><b><code>-v</code></b></td>
    <td>
      how verbose output will full command usage.
    </td>
  </tr>
  <tr>
    <td><b><code>&lt;cmd&gt;</code></b></td>
    <td>
      Show full command usage only for this command.
    </td>
  </tr>
</table></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdhexdump"><h2>2.23 Hexadecimal Dump of File or Device (hexdump)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
hexdump &lt;file or device&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Dump data in hexadecimal format from a file or character device.
</p>

<tr>
  <td><br></td>
  <td>
    <a href="#"></a>
  </td>
</tr>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdifconfig"><h2>2.24 Manage Network Configuration (ifconfig)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
ifconfig [nic_name [&lt;ip-address&gt;|dhcp]] [dr|gw|gateway &lt;dr-address&gt;] [netmask &lt;net-mask&gt;] [dns &lt;dns-address&gt;] [hw &lt;hw-mac&gt;]]
</pre></ul>
<p>
  <b>Synopsis</b>.
  Multiple forms of the <code>ifconfig</code>command are supported:
</p>
<ol>
  <li>
    <p>
      With one or no arguments, <code>ifconfig</code> will shows the
      current configuration of the network and, perhaps, the status of ethernet
      device:
    </p>
    <ul><pre>
ifconfig
ifconfig [nic_name]
</pre></ul>
    <p>
      As an example:
    </p>
    <ul><pre>
nsh&gt; ifconfig
eth0    HWaddr 00:18:11:80:10:06
        IPaddr:10.0.0.2 DRaddr:10.0.0.1 Mask:255.255.255.0
</pre></ul>
    <p>
      If network statistics are enabled (<code>CONFIG_NET_STATISTICS</code>), then
      this command will also show the detailed state of network.
    </p>
  </li>
  <li>
    <p>
      If both the network interface name and an IP address are supplied as arguments,
      then <code>ifconfig</code> will set the address of the ethernet device:
    </p>
    <ul><pre>
ifconfig nic_name ip_address
</pre></ul>
  </li>
  <li>
    Other forms <i>to be provided</i>
  </li>
</ol>
<p>
NOTE: This commands depends upon having the <i>procfs</i> file system configured into the system.
The <i>procfs</i> file system must also have been mounted with a command like:
</p>
<ul><pre>
nsh&gt; mount -t procfs /proc
</pre></ul>
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdifdown"><h2>2.25 Take a network down (ifdown)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
ifdown &lt;nic-name&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Take down the interface identified by the name &lt;nic-name&gt;.
</p>
<p>
  <b>Example:</b>
</p>
<ul><pre>
ifdown eth0
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdifup"><h2>2.26 Bring a network up (ifup)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
ifup &lt;nic-name&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Bring up down the interface identified by the name &lt;nic-name&gt;.
</p>
<p>
  <b>Example:</b>
</p>
<ul><pre>
ifup eth0
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdinsmod"><h2>2.27 Install an OS module (insmod)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
insmod &lt;file-path&gt; &lt;module-name&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Install the loadable OS module at &lt;file-path&gt; as module &lt;module-name&gt;.
</p>
<p><b>Example:</b></p>
<ul><pre>
nsh&gt; ls -l /mnt/romfs
/mnt/romfs:
 dr-xr-xr-x       0 .
 -r-xr-xr-x    9153 chardev
nsh&gt; ls -l /dev
/dev:
 crw-rw-rw-       0 console
 crw-rw-rw-       0 null
 brw-rw-rw-       0 ram0
 crw-rw-rw-       0 ttyS0
nsh&gt; lsmod
NAME                 INIT   UNINIT      ARG     TEXT     SIZE     DATA     SIZE
nsh&gt; insmod /mnt/romfs/chardev mydriver
nsh&gt; ls -l /dev
/dev:
 crw-rw-rw-       0 chardev
 crw-rw-rw-       0 console
 crw-rw-rw-       0 null
 brw-rw-rw-       0 ram0
 crw-rw-rw-       0 ttyS0
nsh&gt; lsmod
NAME                 INIT   UNINIT      ARG     TEXT     SIZE     DATA     SIZE
mydriver         20404659 20404625        0 20404580      552 204047a8        0
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdkill"><h2>2.28 Send a signal to a task (kill)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
kill -&lt;signal&gt; &lt;pid&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Send the &lt;signal&gt; to the task identified by &lt;pid&gt;.
</p>
<p><b>Example:</b></p>
<ul><pre>
nsh&gt; mkfifo /dev/fifo
nsh&gt; cat /dev/fifo &
cat [2:128]
nsh&gt; ps
PID PRI POLICY   TYPE    NPX STATE    EVENT     SIGMASK  COMMAND
  0   0 FIFO     Kthread --- Ready              00000000 Idle Task
  1 128 RR       Task    --- Running            00000000 init
  2 128 FIFO     pthread --- Waiting  Semaphore 00000000 &lt;pthread&gt;(51ea50)
nsh&gt; kill -9 2
nsh&gt; ps
PID PRI POLICY   TYPE    NPX STATE    EVENT     SIGMASK  COMMAND
  0   0 FIFO     Kthread --- Ready              00000000 Idle Task
  1 128 RR       Task    --- Running            00000000 init
nsh&gt;
</pre></ul>
<p><small>
  <b>NOTE</b>:
  NuttX does not support a FULL POSIX signalling system.
  Standard signals like SIGCHLD, SIGINTR, SIGKILL, etc. do not exist in NuttX and sending those signal may not have the result that you expect.
  Rather, NuttX supports only what are referred to as POSIX real-time signals.
  These signals may be used to communicate with running tasks, may be use to waiting waiting tasks, etc.
  But, as an example, <code>kill -9</code> (SIGKILL) will not terminate a task.
</p></small>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdlosetup"><h2>2.29 Setup/teardown the Loop Device (losetup)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax 1:</b></p>
<ul><pre>
losetup [-o &lt;offset&gt;] [-r] &lt;dev-path&gt; &lt;file-path&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
   Setup the loop device at &lt;dev-path&gt; to access the file at &lt;file-path&gt; as a block device.
   In the following example a 256K file is created (<code>dd</code>) and <code>losetup</code> is
   used to make the file accessible as a block device.
   A FAT file system is created (<code>mkfatfs</code>) and mounted (<code>mount</code>).
   Files can then be managed on the loop-mounted file.
<ul><pre>
nsh&gt; dd if=/dev/zero of=/tmp/image bs=512 count=512
nsh&gt; ls -l /tmp
/tmp:
 -rw-rw-rw-   262144 IMAGE
nsh&gt; losetup /dev/loop0 /tmp/image
nsh&gt; ls -l /dev
/dev:
 brw-rw-rw-       0 loop0
nsh&gt; mkfatfs /dev/loop0
nsh&gt; mount -t vfat /dev/loop0 /mnt/example
nsh&gt; ls -l /mnt
ls -l /mnt
/mnt:
 drw-rw-rw-       0 example/
nsh&gt; echo &quot;This is a test&quot; &gt;/mnt/example/atest.txt
nsh&gt; ls -l /mnt/example
/mnt/example:
 -rw-rw-rw-      16 ATEST.TXT
nsh&gt; cat /mnt/example/atest.txt
This is a test
nsh&gt;
</pre></ul>
</p>

<p><b>Command Syntax 2:</b></p>
<ul><pre>
losetup d &lt;dev-path&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Teardown the setup for the loop device at &lt;dev-path&gt;.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdls"><h2>2.30 List Directory Contents (ls)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
ls [-lRs] &lt;dir-path&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Show the contents of the directory at <code>&lt;dir-path&gt;</code>.  NOTE:
  <code>&lt;dir-path&gt;</code> must refer to a directory and no other filesystem
  object.
</p>
<p><b>Options:</b></p>
<ul><table>
  <tr>
    <td><b><code>-R</code></b></td>
    <td>Show the contents of specified directory and all of its
        sub-directories.</td>
  </tr>
  <tr>
    <td><b><code>-s</code></b></td>
    <td>Show the size of the files along with the filenames in the
        listing</td>
  </tr>
  <tr>
    <td><b><code>-l</code></b></td>
    <td>Show size and mode information along with the filenames
        in the listing.</td>
  </tr>
</table></ul>


<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdlsmod"><h2>2.31 Show information about installed OS modules (lsmod)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
lsmod
</pre></ul>
<p>
  <b>Synopsis</b>.
  Show information about the currently installed OS modules.  This information includes:
</p>
<ul>
  <li>The module name assigned to the module when it was installed (<code>NAME</code>, string).</li>
  <li>The address of the module initialization function (<code>INIT</code>, hexadecimal).</li>
  <li>The address of the module un-initialization function (<code>UNINIT</code>, hexadecimal).</li>
  <li>An argument that will be passed to the module un-initialization function (<code>ARG</code>, hexadecimal).</li>
  <li>The start of the .text memory region (<code>TEXT</code>, hexadecimal).</li>
  <li>The size of the .text memory region size (<code>SIZE</code>, decimal).</li>
  <li>The start of the .bss/.data memory region (<code>DATA</code>, hexadecimal).</li>
  <li>The size of the .bss/.data memory region size (<code>SIZE</code>, decimal).</li>
</ul>
<p><b>Example:</b></p>
<ul><pre>
nsh&gt; lsmod
NAME                 INIT   UNINIT      ARG     TEXT     SIZE     DATA     SIZE
mydriver         20404659 20404625        0 20404580      552 204047a8        0
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdmd5"><h2>2.32 Calculate MD5 (md5)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
md5 [-f] &lt;string or filepath&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  <i>To be provided.</i>
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdmbhw"><h2>2.33 Access Memory (mb, mh, and mw)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
mb &lt;hex-address&gt;[=&lt;hex-value&gt;][ &lt;hex-byte-count&gt;]
mh &lt;hex-address&gt;[=&lt;hex-value&gt;][ &lt;hex-byte-count&gt;]
mw &lt;hex-address&gt;[=&lt;hex-value&gt;][ &lt;hex-byte-count&gt;]
</pre></ul>
<p>
  <b>Synopsis</b>.
  Access memory using byte size access (mb), 16-bit accesses (mh),
  or 32-bit access (mw).  In each case,
</p>
<ul><table>
  <tr>
    <td><code>&lt;hex-address&gt;</code>.</td>
    <td>Specifies the address to be accessed.  The current
      value at that address will always be read and displayed.
  </tr>
  <tr>
    <td><code>&lt;hex-address&gt;=&lt;hex-value&gt;</code>.</td>
    <td>Read the value, then write <code>&lt;hex-value&gt;</code>
      to the location.
  </tr>
  <tr>
    <td><code>&lt;hex-byte-count&gt;</code>.</td>
    <td>Perform the mb, mh, or mw operation on a total
      of <code>&lt;hex-byte-count&gt;</code> bytes, increment the <code>&lt;hex-address&gt;</code> appropriately
      after each access
  </tr>
</table></ul>
<p><b>Example:</b><p>
<ul><pre>
nsh&gt; mh 0 16
  0 = 0x0c1e
  2 = 0x0100
  4 = 0x0c1e
  6 = 0x0110
  8 = 0x0c1e
  a = 0x0120
  c = 0x0c1e
  e = 0x0130
  10 = 0x0c1e
  12 = 0x0140
  14 = 0x0c1e
nsh&gt;
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdps"><h2>2.34 Show Current Tasks and Threads (ps)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
ps
</pre></ul>
<p>
  <b>Synopsis</b>.
  Show the currently active threads and tasks.  For example,
</p>
<ul><pre>
nsh&gt; ps
PID PRI POLICY   TYPE    NPX STATE    EVENT     SIGMASK  COMMAND
  0   0 FIFO     Kthread --- Ready              00000000 Idle Task
  1 128 RR       Task    --- Running            00000000 init
  2 128 FIFO     Task    --- Waiting  Semaphore 00000000 nsh_telnetmain()
  3 100 RR       pthread --- Waiting  Semaphore 00000000 &lt;pthread&gt;(21)
nsh&gt;
</pre></ul>
<p>
NOTE: This commands depends upon having the <i>procfs</i> file system configured into the system.
The <i>procfs</i> file system must also have been mounted with a command like:
</p>
<ul><pre>
nsh&gt; mount -t procfs /proc
</pre></ul>
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdmkdir"><h2>2.35 Create a Directory (mkdir)</h2></a>
  </td>
</tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
mkdir &lt;path&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Create the directory at <code>&lt;path&gt;</code>.
  All components of of <code>&lt;path&gt;</code> except the final directory name must exist on a mounted file
  system; the final directory must not.
</p>
<p>
  <b>Limited to Mounted File Systems</b>.
  Recall that NuttX uses a <a href="NuttxUserGuide.html#FileSystemOverview"><i>pseudo</i> filesystem</a> for its root file
  system.
  The <code>mkdir</code> command can only be used to create directories in volumes set up with the
  <a href="#cmdmount"><code>mount</code></a> command; it cannot be used to create directories in the <i>pseudo</i> filesystem.
</p>
<p><b>Example:</b></p>
<ul><pre>
nsh&gt; mkdir /mnt/fs/tmp
nsh&gt; ls -l /mnt/fs
/mnt/fs:
 drw-rw-rw-       0 TESTDIR/
 drw-rw-rw-       0 TMP/
nsh&gt;
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdmkfatfs"><h2>2.36 Create a FAT Filesystem (mkfatfs)</h2></a>
  </td>
</tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
mkfatfs [-F &lt;fatsize&gt;] &lt;block-driver&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Format a fat file system on the block device specified by <code>&lt;block-driver&gt;</code> path.
  The FAT size may be provided as an option.
  Without the <code>&lt;fatsize&gt;</code> option, <code>mkfatfs</code> will select either the FAT12 or FAT16 format.
  For historical reasons, if you want the FAT32 format, it must be explicitly specified on the command line.
</p>
<p>
  NSH provides this command to access the <a href="mkfatfs"><code>mkfatfs()</code></a> NuttX API.
  This block device must reside in the NuttX <a href="NuttxUserGuide.html#FileSystemOverview"><i>pseudo</i> filesystem</a> and
  must have been created by some call to <code>register_blockdriver()</code> (see <code>include/nuttx/fs/fs.h</code>).
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdmkfifo"><h2>2.37 Create a FIFO (mkfifo)</h2></a>
  </td>
</tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
mkfifo &lt;path&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Creates a FIFO character device anywhere in the pseudo file system, creating
  whatever pseudo directories that may be needed to complete the <code>&lt;path&gt;</code>.
  By convention, however, device drivers are place in the standard <code>/dev</code> directory.
  After it is created, the FIFO device may be used as any other device driver.
  NSH provides this command to access the <a href="NuttxUserGuide.html#mkfifo"><code>mkfifo()</code></a> NuttX API.
</p>
<p><b>Example</b></p>
<ul><pre>
nsh&gt; ls -l /dev
/dev:
 crw-rw-rw-       0 console
 crw-rw-rw-       0 null
 brw-rw-rw-       0 ram0
nsh&gt; mkfifo /dev/fifo
nsh&gt; ls -l /dev
ls -l /dev
/dev:
 crw-rw-rw-       0 console
 crw-rw-rw-       0 fifo
 crw-rw-rw-       0 null
 brw-rw-rw-       0 ram0
nsh&gt;
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdmkrd"><h2>2.38 Create a RAMDISK (mkrd)</h2></a>
  </td>
</tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
mkrd [-m &lt;minor&gt;] [-s &lt;sector-size&gt;] &lt;nsectors&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Create a ramdisk consisting of <code>&lt;nsectors&gt;</code>, each of size
  <code>&lt;sector-size&gt;</code> (or 512 bytes if <code>&lt;sector-size&gt;</code> is not specified.
  The ramdisk will be registered as <code>/dev/ram&lt;n&gt;</code> (if <code>&lt;n&gt;</code> is not
  specified, mkrd will attempt to register the ramdisk as <code>/dev/ram0</code>.
</p>
<p><b>Example</b></p>
<ul><pre>
nsh&gt; ls /dev
/dev:
 console
 null
 ttyS0
 ttyS1
nsh&gt; mkrd 1024
nsh&gt; ls /dev
/dev:
 console
 null
 ram0
 ttyS0
 ttyS1
nsh&gt;
</pre></ul>
<p>
  Once the ramdisk has been created, it may be formatted using
  the <code>mkfatfs</code> command and mounted using the <code>mount</code> command.
</p>
<p><b>Example</b></p>
<ul><pre>
nsh&gt; mkrd 1024
nsh&gt; mkfatfs /dev/ram0
nsh&gt; mount -t vfat /dev/ram0 /tmp
nsh&gt; ls /tmp
/tmp:
nsh&gt;
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdmount"><h2>2.39 Mount a File System (mount)</h2></a>
  </td>
</tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
mount -t &lt;fstype&gt; [-o &lt;options&gt;] &lt;block-device&gt; <code>&lt;dir-path&gt;</code>
</pre></ul>
<p>
  <b>Synopsis</b>.
  The <code>mount</code> command performs one of two different operations.
  If no parameters are provided on the command line after the <code>mount</code> command, then the <code>mount</code> command will enumerate all of the current mountpoints on the console.
</p>
<p>
  If the mount parameters are provied on the command after the <code>mount</code> command, then the <code>mount</code> command will mount a file system in the NuttX pseudo-file system.
  <code>mount</code>' performs a three way association, binding:
</p>
<ol>
  <li><b>File system.</b>
    The '-t <code>&lt;fstype&gt;</code>' option identifies the type of
    file system that has been formatted on the <code>&lt;block-device&gt;</code>.
    As of this writing, <code>vfat</code> is the only supported value for <code>&lt;fstype&gt;</code>
  </li>
  <li><b>Block Device.</b>
    The <code>&lt;block-device&gt;</code> argument is the full or relative
    path to a block driver inode in the <a href="NuttxUserGuide.html#FileSystemOverview"><i>pseudo</i> filesystem</a>.
    By convention, this is a name under the <code>/dev</code> sub-directory.
    This <code>&lt;block-device&gt;</code>  must have been previously formatted with the same file system
    type as specified by <code>&lt;fstype&gt;</code>
  </li>
  <li><b>Mount Point.</b>
    The mount point, <code>&lt;dir-path&gt;</code>, is the location in the
    <a href="NuttxUserGuide.html#FileSystemOverview"><i>pseudo</i> filesystem</a> where the mounted volume will appear.
    This mount point can only reside in the NuttX <a href="NuttxUserGuide.html#FileSystemOverview"><i>pseudo</i> filesystem</a>.
    By convention, this mount point is a subdirectory under <code>/mnt</code>.
    The mount command will create whatever pseudo directories that may be needed to complete the
    full path but the full path must not already exist.
  </li>
</ol>
<p>
  After the volume has been mounted in the NuttX
  <a href="NuttxUserGuide.html#FileSystemOverview"><i>pseudo</i> filesystem</a>,
  it may be access in the same way as other objects in thefile system.
</p>
<p><b>Examples</b>:</p>
<p>Using <code>mount</code> to mount a file system:</p>
<ul><pre>
nsh&gt; ls -l /dev
/dev:
 crw-rw-rw-       0 console
 crw-rw-rw-       0 null
 brw-rw-rw-       0 ram0
nsh&gt; ls /mnt
nsh: ls: no such directory: /mnt
nsh&gt; mount -t vfat /dev/ram0 /mnt/fs
nsh&gt; ls -l /mnt/fs/testdir
/mnt/fs/testdir:
 -rw-rw-rw-      15 TESTFILE.TXT
nsh&gt; echo "This is a test" >/mnt/fs/testdir/example.txt
nsh&gt; ls -l /mnt/fs/testdir
/mnt/fs/testdir:
-rw-rw-rw-      15 TESTFILE.TXT
 -rw-rw-rw-      16 EXAMPLE.TXT
nsh&gt; cat /mnt/fs/testdir/example.txt
This is a test
nsh&gt;
</pre></ul>
<p>Using <code>mount</code> to enumerate mounts:</p>
<ul><pre>
nsh&gt; mount
  /etc type romfs
  /mnt/fs type vfat
  /tmp type vfat
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdmv"><h2>2.40 Rename a File (mv)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
mv &lt;old-path&gt; &lt;new-path&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Rename the file object at <code>&lt;old-path&gt;</code> to <code>&lt;new-path&gt;</code>.
  Both paths must reside in the same mounted filesystem.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdnfsmount"><h2>2.41 Mount an NFS file system (nfsmount)</h2></a>
  </td>
  </tr>
</table>
    <a href="#"></a>

<p><b>Command Syntax:</b></p>
<ul><pre>
nfsmount &lt;server-address&gt; &lt;mount-point&gt; &lt;remote-path&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Mount the remote NFS server directory&lt;remote-path&gt; at &lt;mount-point&gt; on the target machine.
  &lt;server-address&gt; is the IP address of the remote server.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdnslookup"><h2>2.42 Lookup a network address (nslookup)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
nslookup &lt;host-name&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Lookup and print the IP address associated with <code>&lt;host-name&gt;</code>.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdpasswd"><h2>2.43 Change a User's Password (passwd)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
passwd &lt;username&gt; &lt;password&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Set the password for the existing user &lt;username&gt; to &lt;password&gt;.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdping"><h2>2.44 Check Network Peer (ping/ping6)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
ping  [-c &lt;count&gt;] [-i &lt;interval&gt;] &lt;ip-address&gt;
ping6 [-c &lt;count&gt;] [-i &lt;interval&gt;] &lt;ip-address&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Test the network communication with a remote peer.  Example,
</p>
<ul><pre>
nsh&gt; ping 10.0.0.1
PING 10.0.0.1 56 bytes of data
56 bytes from 10.0.0.1: icmp_seq=1 time=0 ms
56 bytes from 10.0.0.1: icmp_seq=2 time=0 ms
56 bytes from 10.0.0.1: icmp_seq=3 time=0 ms
56 bytes from 10.0.0.1: icmp_seq=4 time=0 ms
56 bytes from 10.0.0.1: icmp_seq=5 time=0 ms
56 bytes from 10.0.0.1: icmp_seq=6 time=0 ms
56 bytes from 10.0.0.1: icmp_seq=7 time=0 ms
56 bytes from 10.0.0.1: icmp_seq=8 time=0 ms
56 bytes from 10.0.0.1: icmp_seq=9 time=0 ms
56 bytes from 10.0.0.1: icmp_seq=10 time=0 ms
10 packets transmitted, 10 received, 0% packet loss, time 10190 ms
nsh&gt;
</pre></ul>
<p>
  <code>ping6</code> differs from <code>ping</code> in that it uses IPv6 addressing.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdpoweroff"><h2>2.45 Shut the system down (poweroff)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
poweroff
</pre></ul>
<p>
  <b>Synopsis</b>.
  Shutdown and power off the system immediately.
  This command depends on hardware support to power down the system.
</p>
<p>
  NOTE: Supporting both the <code>poweroff</code> and <code>shutdown</code> commands is redundant.
</p>


<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdput"><h2>2.46 Send File Via TFTP (put)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
put [-b|-n] [-f &lt;remote-path&gt;] -h &lt;ip-address&gt; &lt;local-path&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Copy the file at <code>&lt;local-address&gt;</code> to the host whose IP address is
  identified by <code>&lt;ip-address&gt;</code>.
</p>
<p><b>Other options:</b></p>
<ul><table>
  <tr>
    <td><b><code>-f &lt;remote-path&gt;</code></b></td>
    <td>
      The file will be saved relative with the same name on the host
      unless <code>&lt;remote-path&gt;</code> is provided.
    </td>
  </tr>
  <tr>
    <td><b><code>-b|-n</code></b></td>
    <td>
      Selects either binary (&quot;octet&quot;) or test (&quot;netascii&quot;) transfer
      mode.  Default: text.
    </td>
  </tr>
</table></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdpwd"><h2>2.47 Show Current Working Directory (pwd)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
pwd
</pre></ul>
<p>
  <b>Synopsis</b>.
  Show the current working directory.
</p>
<ul><pre>
nsh&gt; cd /dev
nsh&gt; pwd
/dev
nsh&gt;
</pre></ul>

<p>Same as <code><a href="#cmdecho">echo</a> <a href="#environvars">$PWD</a></code>.</p>
<ul><pre>
nsh&gt; echo $PWD
/dev
nsh&gt;
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdreboot"><h2>2.48 Reboot the system (reboot)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
reboot
</pre></ul>
<p>
  <b>Synopsis</b>.
  Reset and reboot the system immediately.
  This command depends on hardware support to reset the system.
</p>
<p>
<p>
  NOTE: Supporting both the <code>reboot</code> and <code>shutdown</code> commands is redundant.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdrm"><h2>2.49 Remove a File (rm)</h2></a>
  </td>
</tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
rm &lt;file-path&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Remove the specified <code>&lt;file-path&gt;</code> name from the mounted file system.
  Recall that NuttX uses a <a href="NuttxUserGuide.html#FileSystemOverview"><i>pseudo</i> filesystem</a> for its root file
  system.
  The <code>rm</code> command can only be used to remove (unlink) files in volumes set up with the
  <a href="#cmdmount"><code>mount</code></a> command;
  it cannot be used to remove names in the <i>pseudo</i> filesystem.
</p>
<p><b>Example:</b></p>
<ul><pre>
nsh&gt; ls /mnt/fs/testdir
/mnt/fs/testdir:
 TESTFILE.TXT
 EXAMPLE.TXT
nsh&gt; rm /mnt/fs/testdir/example.txt
nsh&gt; ls /mnt/fs/testdir
/mnt/fs/testdir:
 TESTFILE.TXT
nsh&gt;
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdrmdir"><h2>2.50 Remove a Directory (rmdir)</h2></a>
  </td>
</tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
rmdir &lt;dir-path&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Remove the specified <code>&lt;dir-path&gt;</code> directory from the mounted file system.
  Recall that NuttX uses a <a href="NuttxUserGuide.html#FileSystemOverview"><i>pseudo</i> filesystem</a> for its root file
  system.
  The <code>rmdir</code> command can only be used to remove directories from volumes set up with the
  <a href="#cmdmount"><code>mount</code></a> command;
  it cannot be used to remove directories from the <i>pseudo</i> filesystem.
</p>
<p><b>Example:</b></p>
<ul><pre>
nsh&gt; mkdir /mnt/fs/tmp
nsh&gt; ls -l /mnt/fs
/mnt/fs:
 drw-rw-rw-       0 TESTDIR/
 drw-rw-rw-       0 TMP/
nsh&gt; rmdir /mnt/fs/tmp
nsh&gt; ls -l /mnt/fs
/mnt/fs:
 drw-rw-rw-       0 TESTDIR/
nsh&gt;
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdrmmod"><h2>2.51 Remove on OS Module (rmmod)</h2></a>
  </td>
</tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
rmmod &lt;module-name&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Remove the loadable OS module with the &lt;module-name&gt;.
  NOTE: An OS module can only be removed if it is not busy.
</p>
<p><b>Example:</b></p>
<ul><pre>
nsh&gt; lsmod
NAME                 INIT   UNINIT      ARG     TEXT     SIZE     DATA     SIZE
mydriver         20404659 20404625        0 20404580      552 204047a8        0
nsh&gt; rmmod mydriver
nsh&gt; lsmod
NAME                 INIT   UNINIT      ARG     TEXT     SIZE     DATA     SIZE
nsh&gt;
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdset"><h2>2.52 Set an Environment Variable (set)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
set &lt;name&gt; &lt;value&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Set the environment variable <code>&lt;name&gt;</code> to the string <code>&lt;value&gt;</code>.
  For example,
</p>
<ul><pre>
nsh&gt; echo $foobar

nsh&gt; set foobar foovalue
nsh&gt; echo $foobar
foovalue
nsh&gt;
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdsh"><h2>2.53 Execute an NSH Script (sh)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
sh &lt;script-path&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Execute the sequence of NSH commands in the file referred
  to by <code>&lt;script-path&gt;</code>.
</p>


<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdshutdown"><h2>2.54 Shut the system down (shutdown)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
shutdown [--reboot]
</pre></ul>
<p>
  <b>Synopsis</b>.
  Shutdown and power off the system or, optionally, reset and reboot the system immediately.
  This command depends on hardware support to power down or reset the system; one, both, or neither behavior may be supported.
</p>
<p>
  NOTE: The <code>shutdown</code> command duplicates the behavior of the <code>poweroff</code> and <code>eboot</code> commands.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdsleep"><h2>2.55 Wait for Seconds (sleep)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
sleep &lt;sec&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Pause execution (sleep) for <code>&lt;sec&gt;</code> seconds.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdtime"><h2>2.56 Time execution of another command (time)</h2></a>
  </td>
</tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
time &quot;&lt;command&gt;&quot;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Perform command timing.
  This command will execute the following &lt;command&gt; string and then show how much time was required to execute the command.
  Time is shown with a resolution of 100 microseconds which may be beyond the resolution of many configurations.
  Note that the &lt;command&gt; must be enclosed in quotation marks if it contains spaces or other delimiters.
</p>
<p><b>Example:</b></p>
<ul><pre>
nsh&gt; time "sleep 2"

2.0100 sec
nsh&gt;
</pre></ul>
<p>
  The additional 10 millseconds in this example is due to the way that the sleep command works: It always waits one system clock tick longer than requested and this test setup used a 10 millisecond periodic system
  timer.
  Sources of error could include various quantization errors, competing CPU usage, and the additional overhead of the time command execution itself which is included in the total.
</p>
<p>
  The reported time is the elapsed time from starting of the command to completion of the command.
  This elapsed time may not necessarily be just the processing time for the command.
  It may included interrupt level processing, for example.
  In a busy system, command processing could be delayed if pre-empted by other, higher priority threads competing for CPU time.
  So the reported time includes all CPU processing from the start of the command to its finish possibly including unrelated processing time during that interval.
</p>
<p>
  Notice that:
</p>
<ul><pre>
nsh&gt; time "sleep 2 &"
sleep [3:100]

0.0000 sec
nsh&gt;
</pre></ul>
<p>
  Since the sleep command is executed in background, the sleep command completes almost immediately.
  As opposed to the following where the time command is run in background with the sleep command:
</p>
<ul><pre>
nsh&gt; time "sleep 2" &
time [3:100]
nsh&gt;
2.0100 sec
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdunmount"><h2>2.57 Unmount a File System (umount)</h2></a>
  </td>
</tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
umount &lt;dir-path&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Un-mount the file system at mount point <code>&lt;dir-path&gt;</code>.
  The <code>umount</code> command can only be used to un-mount volumes previously mounted using
  <a href="#cmdmount"><code>mount</code></a> command.
</p>
<p><b>Example:</b></p>
<ul><pre>
nsh&gt; ls /mnt/fs
/mnt/fs:
 TESTDIR/
nsh&gt; umount /mnt/fs
nsh&gt; ls /mnt/fs
/mnt/fs:
nsh: ls: no such directory: /mnt/fs
nsh&gt;
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmduname"><h2>2.58 Print system information (uname)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
uname [-a | -imnoprsv]
</pre></ul>
<p>
  <b>Synopsis</b>.
  Print certain system information.  With no options, the output is the same as -s.
<p>
<ul><table>
  <tr>
    <td><code>-a</code></td>
    <td>
      Print all information, in the following order, except omit -p and -i if unknown:
    </td>
  </tr>
  <tr>
    <td><code>-s, -o</code></td>
    <td>
      Print the operating system name (NuttX)
    </td>
  </tr>
  <tr>
    <td><code>-n</code></td>
    <td>
      Print the network node hostname (only availabel if <code>CONFIG_NET=y</code>)
    </td>
  </tr>
  <tr>
    <td><code>-r</code></td>
    <td>
      Print the kernel release
    </td>
  </tr>
  <tr>
    <td><code>-v</code></td>
    <td>
      Print the kernel version
    </td>
  </tr>
  <tr>
    <td><code>-m</code></td>
    <td>
      Print the machine hardware name
    </td>
  </tr>
  <tr>
    <td><code>-i</code></td>
    <td>
      Print the machine platform name
    </td>
  </tr>
  <tr>
    <td><code>-p</code></td>
    <td>
      Print &quot;unknown&quot;
    </td>
  </tr>
</table></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdunset"><h2>2.59 Unset an Environment Variable (unset)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
unset &lt;name&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Remove the value associated with the environment variable
  <code>&lt;name&gt;</code>.  Example:
</p>
<ul><pre>
nsh&gt; echo $foobar
foovalue
nsh&gt; unset foobar
nsh&gt; echo $foobar

nsh&gt;
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdurldec"><h2>2.60 URL Decode (urldecode)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
urldecode [-f] &lt;string or filepath&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  <i>To be provided.</i>
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdurlencode"><h2>2.61 URL Encode (urlencode)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
urlencode [-f] &lt;string or filepath&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  <i>To be provided.</i>
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmduseradd"><h2>2.62 Add a New User (useradd)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
useradd &lt;username&gt; &lt;password&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Add a new user with &lt;username&gt; and &lt;password&gt;.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmduserdel"><h2>2.63 Delete a user (userdel)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
userdel &lt;username&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Delete the user with the name &lt;username&gt;.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdusleep"><h2>2.64 Wait for Microseconds (usleep)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
usleep &lt;usec&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Pause execution (sleep) of <code>&lt;usec&gt;</code> microseconds.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdwget"><h2>2.65 Get File Via HTTP (wget)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
wget [-o &lt;local-path&gt;] &lt;url&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Use HTTP to copy the file at <code>&lt;url&gt;</code> to the current directory.
</p>
<p><b>Options:</b></p>
<ul><table>
  <tr>
    <td><b><code>-o &lt;local-path&gt;</code></b></td>
    <td>
      The file will be saved relative to the current working directory
      and with the same name as on the HTTP server unless <code>&lt;local-path&gt;</code> is provided.
    </td>
  </tr>
</table></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmdxd"><h2>2.66 Hexadecimal Dump of Memory (xd)</h2></a>
  </td>
  </tr>
</table>

<p><b>Command Syntax:</b></p>
<ul><pre>
xd &lt;hex-address&gt; &lt;byte-count&gt;
</pre></ul>
<p>
  <b>Synopsis</b>.
  Dump <code>&lt;byte-count&gt;</code> bytes of data from address <code>&lt;hex-address&gt;</code>.
</p>
<p><b>Example:</b></p>
<ul><pre>
nsh&gt; xd 410e0 512
Hex dump:
0000: 00 00 00 00 9c 9d 03 00 00 00 00 01 11 01 10 06 ................
0010: 12 01 11 01 25 08 13 0b 03 08 1b 08 00 00 02 24 ....%..........$
...
01f0: 08 3a 0b 3b 0b 49 13 00 00 04 13 01 01 13 03 08 .:.;.I..........
nsh&gt;
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="configuration"><h1>3.0 Configuration Settings</h1></a>
  </td>
  </tr>
</table>

<p>
  The availability of the above commands depends upon features that
  may or may not be enabled in the NuttX configuration file.  The
  following <a href="#cmddependencies">table</a> indicates the dependency of each command on NuttX
  configuration settings.  General configuration settings are discussed
  in the <a href="NuttxPortingGuide.html">NuttX Porting Guide.</a>
  Configuration settings specific to NSH as discussed at the <a href="#nshconfiguration">bottom</a> of this document.
</p>

<p>
  Note that in addition to general NuttX configuation settings, each NSH command can be
  individually disabled via the settings in the rightmost column.
  All of these settings make the configuration of NSH potentially complex but also allow it to
  squeeze into very small memory footprints.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="cmddependencies"><h2>3.1 Command Dependencies on Configuration Settings</h2></a>
  </td>
  </tr>
</table>

<center><p>Table. Command Dependencies on Configuration Settings</p>
<table width="100%">
  <tr bgcolor="#e4e4e4">
    <th align="left" width="25%">Command</th>
    <th align="left">Depends on Configuration</th>
    <th align="left">Can Be Disabled with</th>
  </tr>
  <tr>
    <td><b><code>[</code></b></td>
    <td>!<code>CONFIG_NSH_DISABLESCRIPT</code></td>
    <td><code>CONFIG_NSH_DISABLE_TEST</code></td>
  </tr>
  <tr>
    <td><b><code>addroute</code></b></td>
    <td><code>CONFIG_NET</code> &amp;&amp; <code>CONFIG_NET_ROUTE</code></td>
    <td><code>CONFIG_NSH_DISABLE_ADDROUTE</code></td>
  </tr>
  <tr>
    <td><b><code>arp</code></b></td>
    <td><code>CONFIG_NET</code> &amp;&amp; <code>CONFIG_NET_ARP</code></td>
    <td><code>CONFIG_NSH_DISABLE_ARP</code></td>
  </tr>
  <tr>
    <td><b><code>base64dec</code></b></td>
    <td><code>CONFIG_NETUTILS_CODECS</code> &amp;&amp; <code>CONFIG_CODECS_BASE64</code></td>
    <td><code>CONFIG_NSH_DISABLE_BASE64DEC</code></td>
  </tr>
  <tr>
    <td><b><code>base64enc</code></b></td>
    <td><code>CONFIG_NETUTILS_CODECS</code> &amp;&amp; <code>CONFIG_CODECS_BASE64</code></td>
    <td><code>CONFIG_NSH_DISABLE_BASE64ENC</code></td>
  </tr>
  <tr>
    <td><b><code>basename</code></b></td>
    <td>&nbsp;</td>
    <td><code>CONFIG_NSH_DISABLE_BASENAME</code></td>
  </tr>
  <tr>
    <td><b><code>break</code></b></td>
    <td>!<code>CONFIG_NSH_DISABLESCRIPT</code> &amp;&amp; !<code>CONFIG_NSH_DISABLE_LOOPS</code></td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td><b><code>cat</code></b></td>
    <td><code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0</td>
    <td><code>CONFIG_NSH_DISABLE_CAT</code></td>
  </tr>
  <tr>
    <td><b><code>cd</code></b></td>
    <td>!<code>CONFIG_DISABLE_ENVIRON</code> &amp;&amp; <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0</td>
    <td><code>CONFIG_NSH_DISABLE_CD</code></td>
  </tr>
  <tr>
    <td><b><code>cmp</code></b></td>
    <td><code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0</td>
    <td><code>CONFIG_NSH_DISABLE_CMP</code></td>
  </tr>
  <tr>
    <td><b><code>cp</code></b></td>
    <td><code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0</td>
    <td><code>CONFIG_NSH_DISABLE_CP</code></td>
  </tr>
  <tr>
    <td><b><code>date</code></b></td>
    <td><br></td>
    <td><code>CONFIG_NSH_DISABLE_DATE</code></td>
  </tr>
  <tr>
    <td><b><code>dd</code></b></td>
    <td><code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0</td>
    <td><code>CONFIG_NSH_DISABLE_DD</code></td>
  </tr>
  <tr>
    <td><b><code>delroute</code></b></td>
    <td><code>CONFIG_NET</code> &amp;&amp; <code>CONFIG_NET_ROUTE</code></td>
    <td><code>CONFIG_NSH_DISABLE_DELROUTE</code></td>
  </tr>
  <tr>
    <td><b><code>df</code></b></td>
    <td>!<code>CONFIG_DISABLE_MOUNTPOINT</code> &amp;&amp; <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0 &amp;&amp; <code>CONFIG_FS_READABLE</code><sup>3</sup></td>
    <td><code>CONFIG_NSH_DISABLE_DF</code></td>
  </tr>
  <tr>
    <td><b><code>dirname</code></b></td>
    <td>&nbsp;</td>
    <td><code>CONFIG_NSH_DISABLE_DIRNAME</code></td>
  </tr>
  <tr>
    <td><b><code>echo</code></b></td>
    <td><br></td>
    <td><code>CONFIG_NSH_DISABLE_ECHO</code></td>
  </tr>
  <tr>
    <td><b><code>exec</code></b></td>
    <td><br></td>
    <td><code>CONFIG_NSH_DISABLE_EXEC</code></td>
  </tr>
  <tr>
    <td><b><code>exit</code></b></td>
    <td><br></td>
    <td><code>CONFIG_NSH_DISABLE_EXIT</code></td>
  </tr>
  <tr>
    <td><b><code>free</code></b></td>
    <td><br></td>
    <td><code>CONFIG_NSH_DISABLE_FREE</code></td>
  </tr>
  <tr>
    <td><b><code>get</code></b></td>
    <td><code>CONFIG_NET</code> &amp;&amp; <code>CONFIG_NET_UDP</code> &amp;&amp;
        <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0 &amp;&amp; <i>MTU</i> &gt;= 558<sup>1</sup></td>
    <td><code>CONFIG_NSH_DISABLE_GET</code></td>
  </tr>
  <tr>
    <td><b><code>help</code></b><sup>5</sup></td>
    <td><br></td>
    <td><code>CONFIG_NSH_DISABLE_HELP</code></td>
  </tr>
  <tr>
    <td><b><code>hexdump</code></b></td>
    <td><code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0</td>
    <td><code>CONFIG_NSH_DISABLE_HEXDUMP</code></td>
  </tr>
  <tr>
    <td><b><code>ifconfig</code></b></td>
    <td><code>CONFIG_NET</code> &amp;&amp; <code>CONFIG_FS_PROCFS</code> &amp;&amp; !<code>CONFIG_FS_PROCFS_EXCLUDE_NET</code></td>
    <td><code>CONFIG_NSH_DISABLE_IFCONFIG</code></td>
  </tr>
  <tr>
    <td><b><code>ifdown</code></b></td>
    <td><code>CONFIG_NET</code> &amp;&amp; <code>CONFIG_FS_PROCFS</code> &amp;&amp; !<code>CONFIG_FS_PROCFS_EXCLUDE_NET</code></td>
    <td><code>CONFIG_NSH_DISABLE_IFUPDOWN</code></td>
  </tr>
  <tr>
    <td><b><code>ifup</code></b></td>
    <td><code>CONFIG_NET</code> &amp;&amp; <code>CONFIG_FS_PROCFS</code> &amp;&amp; !<code>CONFIG_FS_PROCFS_EXCLUDE_NET</code></td>
    <td><code>CONFIG_NSH_DISABLE_IFUPDOWN</code></td>
  </tr>
  <tr>
    <td><b><code>insmod</code></b></td>
    <td><code>CONFIG_MODULE</code></td>
    <td><code>CONFIG_NSH_DISABLE_MODCMDS</code></td>
  </tr>
  <tr>
    <td><b><code>kill</code></b></td>
    <td>!<code>CONFIG_DISABLE_SIGNALS</code></td>
    <td><code>CONFIG_NSH_DISABLE_KILL</code></td>
  </tr>
  <tr>
    <td><b><code>losetup</code></b></td>
    <td>!<code>CONFIG_DISABLE_MOUNTPOINT</code> &amp;&amp; <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0 &amp;&amp; <code>CONFIG_DEV_LOOP</code></td>
    <td><code>CONFIG_NSH_DISABLE_LOSETUP</code></td>
  </tr>
  <tr>
    <td><b><code>ls</code></b></td>
    <td><code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0</td>
    <td><code>CONFIG_NSH_DISABLE_LS</code></td>
  </tr>
  <tr>
    <td><b><code>lsmod</code></b></td>
    <td><code>CONFIG_MODULE</code> &amp;&amp; <code>CONFIG_FS_PROCFS</code> &amp;&amp; !<code>CONFIG_FS_PROCFS_EXCLUDE_MODULE</code></td>
    <td><code>CONFIG_NSH_DISABLE_MODCMDS</code></td>
  </tr>
  <tr>
    <td><b><code>md5</code></b></td>
    <td><code>CONFIG_NETUTILS_CODECS</code> &amp;&amp; <code>CONFIG_CODECS_HASH_MD5</code></td>
    <td><code>CONFIG_NSH_DISABLE_MD5</code></td>
  </tr>
  <tr>
    <td><b><code>mb,mh,mw</code></b></td>
    <td><br></td>
    <td>
      <code>CONFIG_NSH_DISABLE_MB</code>,<br>
      <code>CONFIG_NSH_DISABLE_MH</code>,<br>
      <code>CONFIG_NSH_DISABLE_MW</code>
    </td>
  </tr>
  <tr>
    <td><b><code>mkdir</code></b></td>
    <td>(((!<code>CONFIG_DISABLE_MOUNTPOINT</code> &amp;&amp; <code>CONFIG_FS_WRITABLE</code>) || !<code>CONFIG_DISABLE_PSEUDOFS_OPERATIONS</code>) &amp;&amp; <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0)<sup>4</sup></td>
    <td><code>CONFIG_NSH_DISABLE_MKDIR</code></td>
  </tr>
  <tr>
    <td><b><code>mkfatfs</code></b></td>
    <td>!<code>CONFIG_DISABLE_MOUNTPOINT</code> &amp;&amp; <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0 &amp;&amp; <code>CONFIG_FS_FAT</code></td>
    <td><code>CONFIG_NSH_DISABLE_MKFATFS</code></td>
  </tr>
  <tr>
    <td><b><code>mkfifo</code></b></td>
    <td><code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0 &amp;&amp; <code>CONFIG_PIPES</code> &amp;&amp; <code>CONFIG_DEV_FIFO_SIZE</code> &gt; 0</td>
    <td><code>CONFIG_NSH_DISABLE_MKFIFO</code></td>
  </tr>
  <tr>
    <td><b><code>mkrd</code></b></td>
    <td>!<code>CONFIG_DISABLE_MOUNTPOINT</code> &amp;&amp; <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0 &amp;&amp; <code>CONFIG_FS_WRITABLE</code><sup>4</sup></td>
    <td><code>CONFIG_NSH_DISABLE_MKRD</code></td>
  </tr>
  <tr>
    <td><b><code>mount</code></b></td>
    <td>!<code>CONFIG_DISABLE_MOUNTPOINT</code> &amp;&amp; <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0 &amp;&amp; <code>CONFIG_FS_READABLE</code><sup>3</sup></td>
    <td><code>CONFIG_NSH_DISABLE_MOUNT</code></td>
  </tr>
  <tr>
    <td><b><code>mv</code></b></td>
    <td>(((!<code>CONFIG_DISABLE_MOUNTPOINT</code> &amp;&amp; <code>CONFIG_FS_WRITABLE</code>) || !<code>CONFIG_DISABLE_PSEUDOFS_OPERATIONS</code>) &amp;&amp; <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0)<sup>4</sup></td>
    <td><code>CONFIG_NSH_DISABLE_MV</code></td>
  </tr>
  <tr>
    <td><b><code>nfsmount</code></b></td>
    <td>!<code>CONFIG_DISABLE_MOUNTPOINT</code> &amp;&amp; <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0 &amp;&amp; <code>CONFIG_NET</code> &amp;&amp; <code>CONFIG_NFS</code></td>
    <td><code>CONFIG_NSH_DISABLE_NFSMOUNT</code></td>
  </tr>
  <tr>
    <td><b><code>nslookup</code></b></td>
    <td><code>CONFIG_LIBC_NETDB</code> &amp;&amp; <code>CONFIG_NETDB_DNSCLIENT</code></td>
    <td><code>CONFIG_NSH_DISABLE_NSLOOKUP</code></td>
  </tr>
  <tr>
    <td><b><code>passwd</code></b></td>
    <td>!<code>CONFIG_DISABLE_MOUNTPOINT</code> &amp;&amp; <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0 &amp;&amp; <code>CONFIG_FS_WRITABLE</code> &amp;&amp; <code>CONFIG_NSH_LOGIN_PASSWD</code></td>
    <td><code>CONFIG_NSH_DISABLE_PASSWD</code></td>
  </tr>
  <tr>
    <td><b><code>ping</code></b></td>
    <td><code>CONFIG_NET</code> &amp;&amp; <code>CONFIG_NET_ICMP</code> &amp;&amp;
        <code>CONFIG_NET_ICMP_PING</code> &amp;&amp; !<code>CONFIG_DISABLE_SIGNALS</code></td>
    <td><code>CONFIG_NSH_DISABLE_PING</code></td>
  </tr>
  <tr>
    <td><b><code>ping6</code></b></td>
    <td><code>CONFIG_NET</code> &amp;&amp; <code>CONFIG_NET_ICMPv6</code> &amp;&amp;
        <code>CONFIG_NET_ICMPv6_PING</code> &amp;&amp; !<code>CONFIG_DISABLE_SIGNALS</code></td>
    <td><code>CONFIG_NSH_DISABLE_PING6</code></td>
  </tr>
  <tr>
    <td><b><code>poweroff</code></b></td>
    <td><code>CONFIG_BOARDCTL_POWEROFF</td>
    <td><code>CONFIG_NSH_DISABLE_POWEROFF</code></td>
  </tr>
  <tr>
    <td><b><code>ps</code></b></td>
    <td><code>CONFIG_FS_PROCFS</code> &amp;&amp; !<code>CONFIG_FS_PROCFS_EXCLUDE_PROC</code></td>
    <td><code>CONFIG_NSH_DISABLE_PS</code></td>
  </tr>
  <tr>
    <td><b><code>put</code></b></td>
    <td><code>CONFIG_NET</code> &amp;&amp; <code>CONFIG_NET_UDP</code> &amp;&amp;
    <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0 &amp;&amp; <i>MTU</i> &gt;= 558<sup>1,2</sup></td>
    <td><code>CONFIG_NSH_DISABLE_PUT</code></td>
  </tr>
  <tr>
    <td><b><code>pwd</code></b></td>
    <td>!<code>CONFIG_DISABLE_ENVIRON</code> &amp;&amp; <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0</td>
    <td><code>CONFIG_NSH_DISABLE_PWD</code></td>
  </tr>
  <tr>
    <td><b><code>reboot</code></b></td>
    <td><code>CONFIG_BOARD_RESET</code></td>
    <td><code>CONFIG_NSH_DISABLE_REBOOT</code></td>
  </tr>
  <tr>
    <td><b><code>rm</code></b></td>
    <td>(((!<code>CONFIG_DISABLE_MOUNTPOINT</code> &amp;&amp; <code>CONFIG_FS_WRITABLE</code>) || !<code>CONFIG_DISABLE_PSEUDOFS_OPERATIONS</code>) &amp;&amp; <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0)<sup>4</sup></td>
    <td><code>CONFIG_NSH_DISABLE_RM</code></td>
  </tr>
  <tr>
    <td><b><code>rmdir</code></b></td>
    <td>(((!<code>CONFIG_DISABLE_MOUNTPOINT</code> &amp;&amp; <code>CONFIG_FS_WRITABLE</code>) || !<code>CONFIG_DISABLE_PSEUDOFS_OPERATIONS</code>) &amp;&amp; <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0)<sup>4</sup></td>
    <td><code>CONFIG_NSH_DISABLE_RMDIR</code></td>
  </tr>
  <tr>
    <td><b><code>rmmod</code></b></td>
    <td><code>CONFIG_MODULE</code></td>
    <td><code>CONFIG_NSH_DISABLE_MODCMDS</code></td>
  </tr>
  <tr>
    <td><b><code>set</code></b></td>
    <td>!<code>CONFIG_DISABLE_ENVIRON</code></td>
    <td><code>CONFIG_NSH_DISABLE_SET</code></td>
  </tr>
  <tr>
    <td><b><code>sh</code></b></td>
    <td><code>CONFIG_NFILE_DESCRIPTORS &gt; 0 &amp;&amp; <code>CONFIG_NFILE_STREAMS &gt; 0 &amp;&amp; !<code>CONFIG_NSH_DISABLESCRIPT</code></td>
    <td><code>CONFIG_NSH_DISABLE_SH</code></td>
  </tr>
  <tr>
    <td><b><code>shutdown</code></b></td>
    <td><code>CONFIG_BOARDCTL_POWEROFF || CONFIG_BOARD_RESET</code></td>
    <td><code>CONFIG_NSH_DISABLE_SHUTDOWN</code></td>
  </tr>
  <tr>
    <td><b><code>sleep</code></b></td>
    <td>!<code>CONFIG_DISABLE_SIGNALS</code></td>
    <td><code>CONFIG_NSH_DISABLE_SLEEP</code></td>
  </tr>
  <tr>
    <td><b><code>test</code></b></td>
    <td>!<code>CONFIG_NSH_DISABLESCRIPT</code></td>
    <td><code>CONFIG_NSH_DISABLE_TEST</code></td>
  </tr>
  <tr>
    <td><b><code>time</code></b></td>
    <td>&nbsp</td>
    <td><code>CONFIG_NSH_DISABLE_TIME</code></td>
  </tr>
  <tr>
    <td><b><code>umount</code></b></td>
    <td>!<code>CONFIG_DISABLE_MOUNTPOINT</code> &amp;&amp; <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0 &amp;&amp; <code>CONFIG_FS_READABLE</code><sup>3</sup></td>
    <td><code>CONFIG_NSH_DISABLE_UMOUNT</code></td>
  </tr>
  <tr>
    <td><b><code>uname</code></b></td>
    <td>br</td>
    <td><code>CONFIG_NSH_DISABLE_UNAME</code></td>
  </tr>
  <tr>
    <td><b><code>unset</code></b></td>
    <td>!<code>CONFIG_DISABLE_ENVIRON</code></td>
    <td><code>CONFIG_NSH_DISABLE_UNSET</code></td>
  </tr>
  <tr>
    <td><b><code>urldecode</code></b></td>
    <td>!<code>CONFIG_NETUTILS_CODECS</code> &amp;&amp; <code>CONFIG_CODECS_URLCODE</code>
    <td><code>CONFIG_NSH_DISABLE_URLDECODE</code></td>
  </tr>
  <tr>
    <td><b><code>urlencode</code></b></td>
    <td>!<code>CONFIG_NETUTILS_CODECS</code> &amp;&amp; <code>CONFIG_CODECS_URLCODE</code>
    <td><code>CONFIG_NSH_DISABLE_URLENCODE</code></td>
  </tr>
  <tr>
    <td><b><code>useradd</code></b></td>
    <td>!<code>CONFIG_DISABLE_MOUNTPOINT</code> &amp;&amp; <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0 &amp;&amp; <code>CONFIG_FS_WRITABLE</code> &amp;&amp; <code>CONFIG_NSH_LOGIN_PASSWD</code></td>
    <td><code>CONFIG_NSH_DISABLE_USERADD</code></td>
  </tr>
  <tr>
    <td><b><code>userdel</code></b></td>
    <td>!<code>CONFIG_DISABLE_MOUNTPOINT</code> &amp;&amp; <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0 &amp;&amp; <code>CONFIG_FS_WRITABLE</code> &amp;&amp; <code>CONFIG_NSH_LOGIN_PASSWD</code></td>
    <td><code>CONFIG_NSH_DISABLE_USERDEL</code></td>
  </tr>
  <tr>
    <td><b><code>usleep</code></b></td>
    <td>!<code>CONFIG_DISABLE_SIGNALS</code></td>
    <td><code>CONFIG_NSH_DISABLE_USLEEP</code></td>
  </tr>
  <tr>
    <td><b><code>wget</code></b></td>
    <td><code>CONFIG_NET</code> &amp;&amp; <code>CONFIG_NET_TCP</code> &amp;&amp;
        <code>CONFIG_NFILE_DESCRIPTORS</code> &gt; 0</td>
    <td><code>CONFIG_NSH_DISABLE_WGET</code></td>
  </tr>
  <tr>
    <td><b><code>xd</code></b></td>
    <td><br></td>
    <td><code>CONFIG_NSH_DISABLE_XD</code></td>
  </tr>
</table></center>

<p><sup>1</sup><small>
  Because of hardware padding, the actual required packet size may be larger</small><br>
  <sup>2</sup><small>
  Special TFTP server start-up optionss will probably be required to permit
  creation of files for the correct operation of the <code>put</code> command.</small><br>
  <sup>3</sup><small>
  <code>CONFIG_FS_READABLE</code> is not a user configuration but is set automatically
  if any readable filesystem is selected.  At present, this is either <code>CONFIG_FS_FAT</code>
  or <code>CONFIG_FS_ROMFS</code>.</small><br>
  <sup>4</sup><small>
  <code>CONFIG_FS_WRITABLE</code> is not a user configuration but is set automatically
  if any writable filesystem is selected.  At present, this is only <code>CONFIG_FS_FAT</code>.</small><br>
  <sup>5</sup><small>
  Verbose help output can be suppressed by defining <code>CONFIG_NSH_HELP_TERSE</code>.
  In that case, the help command is still available but will be slightly smaller.
  </small>
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="nshconfiguration"><h2>3.2  NSH-Specific Configuration Settings</h2></a>
  </td>
  </tr>
</table>

<p>
  The behavior of NSH can be modified with the following settings in
  the <code>configs/&lt;board-name&gt;/defconfig</code> file:
</p>

<center><table width="100%">
  <tr bgcolor="#e4e4e4">
    <th align="left" width="25%">Configuration</th>
    <th align="left">Description</th>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_READLINE</code></b></td>
    <td>
      Selects the minimal implementation of <code>readline()</code>.
      This minimal implementation provides on backspace for command line editing.
      It expects some minimal VT100 command support from the terminal.
    </td>
  </tr>

  <tr>
    <td valign="top"><b><code>CONFIG_NSH_CLE</code></b></td>
    <td>
      Selects the more extensive, EMACS-like command line editor.
      Select this option only if
      (1) you don't mind a modest increase in the FLASH footprint, and
      (2) you work with a terminal that supports extensive VT100 editing commands.
       Selecting this option will add probably 1.5-2KB to the FLASH footprint.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_BUILTIN_APPS</code></b></td>
    <td>
      Support external registered, &quot;builtin&quot; applications that can be
      executed from the NSH command line (see apps/README.txt for
      more information).
      This required <code>CONFIG_BUILTIN</code> to enable NuttX support for
      &quot;builtin&quot; applications.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_FILEIOSIZE</code></b></td>
    <td>
      Size of a static I/O buffer used for file access (ignored if
      there is no filesystem). Default is 1024.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_STRERROR</code></b></td>
    <td>
      <code>strerror(errno)</code> makes more readable output but <code>strerror()</code> is
      very large and will not be used unless this setting is <i>y</i>.
      This setting depends upon the <code>strerror()</code> having been enabled with <code>CONFIG_LIBC_STRERROR</code>.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_LINELEN</code></b></td>
    <td>
      The maximum length of one command line and of one output line.
      Default: 80
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_DISABLE_SEMICOLON</code></b></td>
    <td>
      By default, you can enter multiple NSH commands on a line with each command separated by a semicolon.
      You can disable this feature to save a little memory on FLASH challenged platforms.
      Default: n
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_CMDPARMS</code></b></td>
    <td>
     If selected, then the output from commands, from file applications, and from NSH built-in commands can be used as arguments to other commands.
     The entity to be executed is identified by enclosing the command line in back quotes.
     For example,
     <ul><pre>
set FOO `myprogram $BAR
</pre></ul>
     will execute the program named  <code>myprogram </code> passing it the value of the environment variable <code>BAR</code>.
     The value of the environment variable <code>FOO</code> is then set output of <code>myprogram</code> on <code>stdout</code>.  Because this feature commits significant resources, it is disabled by default.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_TMPDIR</code></b></td>
    <td>
     If <code>CONFIG_NSH_CMDPARMS</code> is selected, then function output will be retained
     in a temporary file.  In that case, this string must be provided to
     specify the full path to a directory where temporary files can be
     created.  This would be a good application of RAM disk: To provide
     temporary storage for function output.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_MAXARGUMENTS</code></b></td>
    <td>
     The maximum number of NSH command arguments. Default: 6
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_ARGCAT</code></b></td>
    <td>
     Support concatenation of strings with environment variables or command output.
     For example:
     <ul><pre>
set FOO XYZ
set BAR 123
set FOOBAR ABC_${FOO}_${BAR}
</pre></ul>
     would set the environment variable <code>FOO</code> to <code>XYZ</code>, <code>BAR</code> to <code>123</code> and <code>FOOBAR</code> to <code>ABC_XYZ_123</code>.
     If <code>CONFIG_NSH_ARGCAT</code> is not selected, then a slightly small FLASH footprint results but then also only simple environment variables like <code>$FOO</code> can be used on the command line.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_NESTDEPTH</code></b></td>
    <td>
      The maximum number of nested <a href="#conditional"><code>if-then[-else]-fi</code></a> sequences that
      are permissable.  Default: 3
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_DISABLESCRIPT</code></b></td>
    <td>
      This can be set to <i>y</i> to suppress support for scripting.  This
      setting disables the <a href="#cmdsh"><code>sh</code></a>, <a href="#cmdtest"><code>test</code></a>, and <a href="#cmtest"><code>[</code></a> commands and the
      <a href="#conditional"><code>if-then[-else]-fi</code></a> construct.  This would only be set on systems
      where a minimal footprint is a necessity and scripting is not.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_DISABLE_ITEF</code></b></td>
    <td>
      If scripting is enabled, then then this option can be selected to suppress support for <code>if-then-else-fi</code> sequences in scripts.
      This would only be set on systems where some minimal scripting is required but <code>if-then-else-fi</code> is not.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_DISABLE_LOOPS</code></b></td>
    <td>
     If scripting is enabled, then then this option can be selected suppress support <code>for while-do-done</code> and <code>until-do-done</code> sequences in scripts.
     This would only be set on systems where some minimal scripting is required but looping is not.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_DISABLEBG</code></b></td>
    <td>
      This can be set to <i>y</i> to suppress support for background
      commands.  This setting disables the <a href="#cmdoverview"><code>nice</code></a> command prefix and
      the <a href="#cmdoverview"><code>&amp;</code></a> command suffix.  This would only be set on systems
      where a minimal footprint is a necessity and background command execution is not.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_MMCSDMINOR</code></b></td>
    <td>
      If the architecture supports an MMC/SD slot and if the NSH
      architecture specific logic is present, this option will provide
      the MMC/SD minor number, i.e., the MMC/SD block driver will
      be registered as <code>/dev/mmcsd</code><i>N</i> where <i>N</i> is the minor number.
      Default is zero.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_ROMFSETC</code></b></td>
    <td>
      Mount a ROMFS filesystem at <code>/etc</code> and provide a startup script
      at <code>/etc/init.d/rcS</code>.  The default startup script will mount
      a FAT FS RAMDISK at <code>/tmp</code> but the logic is
      <a href="#startupscript">easily extensible</a>.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_CONSOLE</code></b></td>
    <td>
      <p>
        If <code>CONFIG_NSH_CONSOLE</code> is set to <i>y</i>, then a serial
        console front-end is selected.
      </p>
      <p>
        Normally, the serial console device is a UART and RS-232 interface.
        However, if  <code>CONFIG_USBDEV</code> is defined, then a USB serial device may, instead, be used if the one of the following are defined:
      </p>
      <ul>
        <li>
          <code>CONFIG_PL2303</code> and <code>CONFIG_PL2303_CONSOLE</code>.
          Sets up the Prolifics PL2303 emulation as a console device at <code>/dev/console</code>.
        </li>
        <li>
          <code>CONFIG_CDCACM</code> and <code>CONFIG_CDCACM_CONSOLE</code>.
          Sets up the CDC/ACM serial device as a console device at <code>/dev/console</code>.
        </li>
        <li>
          <code>CONFIG_NSH_USBCONSOLE</code>.
          If defined, then the an arbitrary USB device may be used to as the NSH console.
          In this case, <code>CONFIG_NSH_USBCONDEV</code> must be defined to indicate which USB device to use as the console.
          The advantage of using a device other that <code>/dev/console</code> is that normal debug output can then use <code>/dev/console</code> while NSH uses <code>CONFIG_NSH_USBCONDEV</code>.
          <p>
          <code>CONFIG_NSH_USBCONDEV</code>.
          If <code>CONFIG_NSH_USBCONSOLE</code> is set to 'y', then <code>CONFIG_NSH_USBCONDEV</code> must also be set to select the USB device used to support the NSH console.
          This should be set to the quoted name of a readable/write-able USB driver such as: <code>CONFIG_NSH_USBCONDEV="/dev/ttyACM0"</code>.
          </p>
        </li>
      </ul>
      <p>
        If there are more than one USB slots, then a USB device minor number may also need to be provided:
      </p>
      <ul>
        <li>
          <code>CONFIG_NSH_UBSDEV_MINOR</code>.
          The minor device number of the USB device.  Default: 0
        </li>
      </ul>
      <p>
        If USB tracing is enabled (<code>CONFIG_USBDEV_TRACE</code>), then NSH will initialize USB tracing as requested by the following.
        Default:  Only USB errors are traced.
      </p>
      <ul>
        <li>
          <code>CONFIG_NSH_USBDEV_TRACEINIT</code>.
          Show initialization events
        </li>
        <li>
          <code>CONFIG_NSH_USBDEV_TRACECLASS</code>.
          Show class driver events
        </li>
        <li>
          <code>CONFIG_NSH_USBDEV_TRACETRANSFERS</code>.
          Show data transfer events
        </li>
        <li>
          <code>CONFIG_NSH_USBDEV_TRACECONTROLLER</code>.
          Show controller events
        <li>
          <code>CONFIG_NSH_USBDEV_TRACEINTERRUPTS</code>.
          Show interrupt-related events.
        </li>
      </ul>
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_ALTCONDEV</code></b> and <b><code>CONFIG_NSH_CONDEV</code></b></td>
    <td>
      If <code>CONFIG_NSH_CONSOLE</code> is set to <i>y</i>, then <code>CONFIG_NSH_ALTCONDEV</code>
      may also be selected to enable use of an alternate character device to support the NSH console.
      If <code>CONFIG_NSH_ALTCONDEV</code> is selected, then <code>CONFIG_NSH_CONDEV</code> holds the quoted name of a readable/write-able character driver such as:
      <code>CONFIG_NSH_CONDEV=&quot;/dev/ttyS1&quot;</code>.
      This is useful, for example, to separate the NSH command line from the system console
      when the system console is used to provide debug output.
      Default:  <code>stdin</code> and <code>stdout</code> (probably &quot;<code>/dev/console</code>&quot;)
      <ul><small>
        <li>
          <b>NOTE 1:</b>
          When any other device other than <code>/dev/console</code> is used for a user interface,
          (1) linefeeds (<code>\n</code>) will not be expanded to carriage return / linefeeds (<code>\r\n</code>).
          You will need to configure your terminal program to account for this.
          And (2) input is not automatically echoed so you will have to turn local echo on.
        </li>
        <li>
          <b>NOTE 2:</b>
          This option forces the console of all sessions to use NSH_CONDEV.
          Hence, this option only makes sense for a system that supports only a single session.
          This option is, in particular, incompatible with Telnet sessions because each Telnet session must use a different console device.
        </li>
      </small></ul>
    </td>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_TELNET</code></b></td>
    <td>
      If <code>CONFIG_NSH_TELNET</code> is set to <i>y</i>, then a TELENET
      server front-end is selected.  When this option is provided,
      you may log into NuttX remotely using telnet in order to
      access NSH.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_ARCHINIT</code></b></td>
    <td>
      Set <code>CONFIG_NSH_ARCHINIT</code> if your board provides architecture
      specific initialization  via the board-specific function <code>board_app_initialize()</code>.
      This function will be called early in NSH initialization to allow board logic to
      do such things as configure MMC/SD slots.
    </td>
  </tr>
</table></center>

<p>
  If Telnet is selected for the NSH console, then we must configure
  the resources used by the Telnet daemon and by the Telnet clients.
</p>

<center><table width="100%">
  <tr bgcolor="#e4e4e4">
    <th align="left" width="25%">Configuration</th>
    <th align="left">Description</th>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_TELNETD_PORT</code></b></td>
    <td>
      The telnet daemon will listen on this TCP port number for connections.  Default: 23
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_TELNETD_DAEMONPRIO</code></b></td>
    <td>
      Priority of the Telnet daemon.
      Default: <code>SCHED_PRIORITY_DEFAULT</code>
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_TELNETD_DAEMONSTACKSIZE</code></b></td>
    <td>
      Stack size allocated for the
      Telnet daemon. Default: 2048
    </td>
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_TELNETD_CLIENTPRIO</code></b></td>
    <td>
      Priority of the Telnet client.
      Default: <code>SCHED_PRIORITY_DEFAULT</code>
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_TELNETD_CLIENTSTACKSIZE</code></b></td>
    <td>
      Stack size allocated for the Telnet client. Default: 2048
    </td>
  </tr>
</table></center>

<p>
  One or both of <code>CONFIG_NSH_CONSOLE</code> and <code>CONFIG_NSH_TELNET</code>
  must be defined.  If <code>CONFIG_NSH_TELNET</code> is selected, then there some
  other configuration settings that apply:
</p>

<center><table width="100%">
  <tr bgcolor="#e4e4e4">
    <th align="left" width="25%">Configuration</th>
    <th align="left">Description</th>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NET=y</code></b></td>
    <td>
      Of course, networking must be enabled.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSOCKET_DESCRIPTORS</code></b></td>
    <td>
      And, of course, you must allocate some socket descriptors.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NET_TCP=y</code></b></td>
    <td>
      TCP/IP support is required for telnet (as well as various other TCP-related configuration settings).
    </td>
  </tr>
    <td valign="top"><b><code>CONFIG_NSH_IOBUFFER_SIZE</code></b></td>
    <td>
      Determines the size of the I/O buffer to use for sending/
      receiving TELNET commands/reponses
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_DHCPC</code></b></td>
    <td>
      Obtain the IP address via DHCP.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_IPADDR</code></b></td>
    <td>
      If <code>CONFIG_NSH_DHCPC</code> is NOT set, then the static IP
      address must be provided.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_DRIPADDR</code></b></td>
    <td>
      Default router IP address
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_NETMASK</code></b></td>
    <td>
      Network mask
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_NOMAC</code></b></td>
    <td>
      Set if your ethernet hardware has no built-in MAC address.
      If set, a bogus MAC will be assigned.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_MAX_ROUNDTRIP</code></b></td>
    <td>
      This is the maximum round trip for a response to a ICMP ECHO request.
      It is in units of deciseconds.  The default is 20 (2 seconds).
    </td>
  </tr>
</table></center>

<p>
  If you use DHCPC, then some special configuration network options are
  required.  These include:
</p>

<center><table width="100%">
  <tr bgcolor="#e4e4e4">
    <th align="left" width="25%">Configuration</th>
    <th align="left">Description</th>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NET=y</code></b></td>
    <td>
      Of course, networking must be enabled.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSOCKET_DESCRIPTORS</code></b></td>
    <td>
      And, of course, you must allocate some socket descriptors.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NET_UDP=y</code></b></td>
    <td>
      UDP support is required for DHCP (as well as various other UDP-related configuration settings).
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NET_BROADCAST=y</code></b></td>
    <td>
      UDP broadcast support is needed.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NET_ETH_MTU=650</code></b> (or larger)</td>
    <td>
      Per RFC2131 (p. 9), the DHCP client must be prepared to receive DHCP messages of up to
      576 bytes (excluding Ethernet, IP, or UDP headers and FCS).
      NOTE: Note that the actual MTU setting will depend upon the specific link protocol.
      Here Ethernet is indicated.
    </td>
  </tr>
</table></center>

<p>
  If <code>CONFIG_NSH_ROMFSETC</code> is selected, then the following additional
  configuration setting apply:
</p>

<center><table width="100%">
  <tr bgcolor="#e4e4e4">
    <th align="left" width="25%">Configuration</th>
    <th align="left">Description</th>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_ARCHROMFS</code></b></td>
    <td>
      May be defined to specify an alternative ROMFS image that can be found at <code>configs/&lt;board&gt;/include/nsh_romfsimg.h</code>.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_ROMFSMOUNTPT</code></b></td>
    <td>
      The default mountpoint for the ROMFS volume is <code>&quot;/etc&quot;</code>, but that
      can be changed with this setting.  This must be a absolute path
      beginning with '<code>/</code>' and enclosed in quotes.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_INITSCRIPT</code></b></td>
    <td>
      This is the relative path to the startup script within the mountpoint.
      The default is <code>&quot;init.d/rcS&quot;</code>.  This is a relative path and must not
      start with '<code>/</code>' but must be enclosed in quotes.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_ROMFSDEVNO</code></b></td>
    <td>
      This is the minor number of the ROMFS block device.  The default is
      '<code>0</code>' corresponding to <code>/dev/ram0</code>.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_ROMFSSECTSIZE</code></b></td>
    <td>
      This is the sector size to use with the ROMFS volume.  Since the
      default volume is very small, this defaults to 64 but should be
      increased if the ROMFS volume were to be become large.  Any value
      selected must be a power of 2.
    </td>
  </tr>
</table></center>

<p>
  When the default <code>rcS</code> file used when <code>CONFIG_NSH_ROMFSETC</code> is
  selected, it will mount a FAT FS under <code>/tmp</code>.  The following selections
  describe that FAT FS.
</p>

<center><table width="100%">
  <tr bgcolor="#e4e4e4">
    <th align="left" width="25%">Configuration</th>
    <th align="left">Description</th>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_FATDEVNO</code></b></td>
    <td>
      This is the minor number of the FAT FS block device.  The default is
      '<code>1</code>' corresponding to <code>/dev/ram1</code>.
    </td>
  </tr>
  <tr>
    <td valign="top"><b><code>CONFIG_NSH_FATSECTSIZE</code></b></td>
    <td>
      This is the sector size use with the FAT FS. Default is 512.
    </td>
  </tr>
</table></center>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="customizingnsh"><h1>4.0 Customizing the NuttShell</h1></a>
  </td>
  </tr>
</table>

<p>
  <b>Overview.</b>
  The NuttShell (NSH) is a simple shell application that may be used with NuttX.
  It supports a variety of commands and is (very) loosely based on the bash shell and the common utilities used in Unix shell programming.
  The paragraphs in this appendix will focus on customizing NSH:  Adding new commands, changing the initialization sequence, etc.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="custonshlib"><h2>4.1 The NSH Library and NSH Initialization</h2></a>
  </td>
  </tr>
</table>

<p>
  <b>Overview.</b>
  NSH is implemented as a library that can be found at <code>apps/nshlib</code>.
  As a library, it can be custom built into any application that follows the NSH initialization sequence described below.
  As an example, the code at <code>apps/examples/nsh/nsh_main.c</code> illustrates how to start NSH and the logic there was intended to be incorporated into your own custom code.
  Although code was generated simply as an example, in the end most people just use this example code as their application <code>main()</code> function.
  That initialization performed by that example is discussed in the following paragraphs.
</p>

<h3>4.1.1 NSH Initialization sequence</h3>

<p>
  The NSH start-up sequence is very simple.
  As an example, the code at <code>apps/examples/nsh/nsh_main.c</code> illustrates how to start NSH.
  It simple does the following:
</p>

<ol>
  <li>
    <p>
      If you have C++ static initializers, it will call your implementation of <code>up_cxxinitialize()</code> which will, in turn, call those static initializers.
      For the case of the STM3240G-EVAL board, the implementation of <code>up_cxxinitialize()</code> can be found at <code>nuttx/configs/stm3240g-eval/src/up_cxxinitialize.c</code>.
    </p>
  <li>
    <p>
      This function then calls <code>nsh_initialize()</code> which initializes the NSH library.
      <code>nsh_initialize()</code> is described in more detail below.
    </p>
  <li>
    <p>
      If the Telnetconsole is enabled, it calls  <code>nsh_telnetstart()</code> which resides in the NSH library.
      <code>nsh_telnetstart()</code> will start the Telnet daemon that will listen for Telnet connections and start remote NSH sessions.
    </p>
  <li>
    <p>
      If a local console is enabled (probably on a serial port), then <code>nsh_consolemain()</code> is called.
      <code>nsh_consolemain()</code> also resides in the NSH library.
      <code>nsh_consolemain()</code> does not return so that finished the entire NSH initialization sequence.
    </p>
</ol>

<h3>4.1.2 <code>nsh_initialize()</code></h3>

<p>
  The NSH initialization function, <code>nsh_initialize()</code>, be found in <code>apps/nshlib/nsh_init.c</code>.
  It does only three things:
</p>

<ol>
  <li>
    <p>
      <code>nsh_romfsetc()</code>:
      If so configured, it executes an NSH start-up script that can be found at <code>/etc/init.d/rcS</code> in the target file system.
      The <code>nsh_romfsetc()</code> function can be found in <code>apps/nshlib/nsh_romfsetc.c</code>.
      This function will (1) register a ROMFS file system, then (2) mount the ROMFS file system.
      <code>/etc</code> is the default location where a read-only, ROMFS file system is  mounted by <code>nsh_romfsetc()</code>.
    </p>
    <p>
      The ROMFS image is, itself, just built into the firmware.
      By default, this <code>rcS</code> start-up script contains the following logic:
    </p>
<ul><pre>
# Create a RAMDISK and mount it at XXXRDMOUNTPOINTXXX

mkrd -m XXXMKRDMINORXXX -s XXMKRDSECTORSIZEXXX XXMKRDBLOCKSXXX
mkfatfs /dev/ramXXXMKRDMINORXXX
mount -t vfat /dev/ramXXXMKRDMINORXXX XXXRDMOUNTPOINTXXX
</pre></ul>

    <p>
      Where the <code>XXXX*XXXX</code> strings get replaced in the template when the ROMFS image is created:
    </p>
    <ul>
      <li>
        <p>
          <code>XXXMKRDMINORXXX</code> will become the RAM device minor number.
          Default: 0
        </p>
      <li>
        <p>
          <code>XXMKRDSECTORSIZEXXX</code> will become the RAM device sector size
        </p>
      <li>
        <p>
          <code>XXMKRDBLOCKSXXX</code> will become the number of sectors in the device.
        </p>
      <li>
        <p>
          <code>XXXRDMOUNTPOINTXXX</code> will become the configured mount point.
          Default: <code>/etc</code>
        </p>
    </ul>
    <p>
      By default, the substituted values would yield an <code>rcS</code> file like:
    </p>
<ul><pre>
# Create a RAMDISK and mount it at /tmp

mkrd -m 1 -s 512 1024
mkfatfs /dev/ram1
mount -t vfat /dev/ram1 /tmp
</pre></ul>
    <p>
      This script will, then:
    </p>
    <ul>
    <li>
      <p>
        Create a RAMDISK of size 512*1024 bytes at <code>/dev/ram1</code>,
      </p>
    <li>
      <p>
        Format a FAT file system on the RAM disk at <code>/dev/ram1</code>, and then
      </p>
    <li>
      <p>
        Mount the  FAT filesystem at a configured mountpoint, <code>/tmp</code>.
      </p>
    </ul>
    <p>
      This <code>rcS</code> template file can be found at <code>apps/nshlib/rcS.template</code>.
      The resulting ROMFS file system can be found in <code>apps/nshlib/nsh_romfsimg.h</code>.
    </p>
  <li>
    <p>
      <code>board_app_initialize()</code>:
      Next any architecture-specific NSH initialization will be performed (if any).
      For the STM3240G-EVAL, this architecture specific initialization can be found at <code>configs/stm3240g-eval/src/stm32_appinit.c</code>.
      This it does things like:  (1) Initialize SPI devices, (2) Initialize SDIO, and (3) mount any SD cards that may be inserted.
    </p>
  <li>
    <p>
      <code>nsh_netinit()</code>:
      The <code>nsh_netinit()</code> function can be found in <code>apps/nshlib/nsh_netinit.c</code>.
    </p>
</ol>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="custoncmds"><h2>4.2 NSH Commands</h2></a>
  </td>
  </tr>
</table>

<p>
  <b>Overview.</b>
  NSH supports a variety of commands as part of the NSH program.
  All of the NSH commands are listed in the NSH documentation <a href="#cmdoverview">above</a>.
  Not all of these commands may be available at any time, however.
  Many commands depend upon certain NuttX configuration options.
  You can enter the help command at the NSH prompt to see the commands actual available:
</p>
<ul><pre>
nsh&gt; help
</pre></ul>
<p>
  For example, if network support is disabled, then all network-related commands will be missing from the list of commands presented by '<code>nsh&gt; help</code>'.
  You can see the specific command dependencies in the table <a href="#cmddependencies">above</a>.
</p>

<h3>4.2.1 Adding New NSH Commands</h3>

<p>
  New commands can be added to the NSH very easily.
  You simply need to add two things:
</p>
<ol>
  <li>
    <p>
      The implementation of your command, and
    </p>
  <li>
    <p>
      A new entry in the NSH command table
    </p>
</ol>

<p>
  <b>Implementation of Your Command.</b>
  For example, if you want to add a new a new command called <code>mycmd</code> to NSH, you would first implement  the <code>mycmd</code> code in a function with this prototype:
</p>

<ul></pre>
int cmd_mycmd(FAR struct nsh_vtbl_s *vtbl, int argc, char **argv);
</pre></ul>

<p>
  The <code>argc</code> and <code>argv</code> are used to pass command line arguments to the NSH command.
  Command line parameters are passed in a very standard way: <code>argv[0]</code> will be the name of the command, and <code>argv[1]</code> through <code>argv[argc-1]</code> are the additional arguments provided on the NSH command line.
</p>
<p>
  The first parameter, <code>vtbl</code>, is special.
  This is a pointer to session-specific state information.
  You don't need to know the contents of the state information, but you do need to pass this <code>vtbl</code> argument when you interact with the NSH logic.
  The only use you will need to make of the <code>vtbl</code> argument will be for outputting data to the console.
  You don't use <code>printf()</code> within NSH commands.
  Instead you would use:
</p>
<ul><pre>
void nsh_output(FAR struct nsh_vtbl_s *vtbl, const char *fmt, &hellip;);
</pre></ul>
<p>
  So if you only wanted to output &quot;Hello, World!&quot; on the console, then your whole command implementation might be:
</p>
<ul><pre>
int cmd_mycmd(FAR struct nsh_vtbl_s *vtbl, int argc, char **argv)
{
  nsh_output(vtbl, &quote;Hello, World!&quote;);
  return 0;
}
</pre></ul>
<p>
  The prototype for the new command should be placed in <code>apps/examples/nshlib/nsh.h></code>.
</p>

<p>
  <b>Adding You Command to the NSH Command Table</b>.
  All of the commands support by NSH appear in a single table called:
</p>
<ul><pre>
const struct cmdmap_s g_cmdmap[]
</pre></ul>
<p>
  That table can be found in the file <code>apps/examples/nshlib/nsh_parse.c</code>.
  The structure <code>cmdmap_s</code> is also defined in <code>apps/nshlib/nsh_parse.c</code>:
</p>
<ul><pre>
struct cmdmap_s
{
  const char *cmd;        /* Name of the command */
  cmd_t       handler;    /* Function that handles the command */
  uint8_t     minargs;    /* Minimum number of arguments (including command) */
  uint8_t     maxargs;    /* Maximum number of arguments (including command) */
  const char *usage;      /* Usage instructions for 'help' command */
};
</pre></ul>
<p>
  This structure provides everything that you need to describe your command:
  Its name (<code>cmd</code>), the function that handles the command (<code>cmd_mycmd()</code>), the minimum and maximum number of arguments needed by the command,
  and a string describing the command line arguments.
  That last string is what is printed when enter &quot;<code>nsh&gt help</code>&quot;.
</p>
<p>
  So, for you sample commnd, you would add the following the to the <code>g_cmdmap[]</code> table:
</p>
<ul><pre>
{ &quot;mycmd&quot;, cmd_mycmd, 1, 1, NULL },
</pre></ul>

<p>
  This entry is particularly simply because <code>mycmd</code> is so simple.
  Look at the other commands in <code>g_cmdmap[]</code> for more complex examples.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="custapps"><h2>4.3 NSH &quot;Built-In&quot; Applications</h2></a>
  </td>
  </tr>
</table>

<p>
  <b>Overview.</b>
  In addition to these commands that are a part of NSH, external programs can also be executed as NSH commands.
  These external programs are called &quot;Built-In&quot; Applications for historic reasons.
  That terminology is somewhat confusing because the actual NSH commands as described above are truly &quot;built-into&quot; NSH whereas these applications are really external to NuttX.
</p>
<p>
  These applications are built-into NSH in the sense that they can be executed by simply typing the name of the application at the NSH prompt.
  Built-in application support is enabled with these configuration option:
</p>
<ul>
  <li>
    <code>CONFIG_BUILTIN</code>:
    Enable NuttX support for builtin applications.
  </li>
  <li>
    <code>CONFIG_NSH_BUILTIN_APPS</code>:
    Enable NSH support for builtin applications.
  </li>
</ul>
<p>
  When these configuration options are set, you will also be able to see the built-in applications if you enter &quot;nsh&gt; help&quot;.
  They will appear at the bottom of the list of NSH commands under:
</p>

<ul><pre>
Builtin Apps:
</pre></ul>
<p>
  Note that no detailed help information beyond the name of the built-in application is provided.
</p>

<h3>4.3.1 Built-In Applications</h3>

<p>
  <b>Overview.</b>
  The underlying logic that supports the NSH built-in applications is called &quot;Built-In Applications&quot;.
  The builtin application logic can be found at <code>apps/builtin</code>.
  This logic simply does the following:
</p>

<ol>
  <li>
    <p>
      It supports registration mechanism so that builtin applications can dynamically register themselves at build time, and
    </p>
  <li>
    <p>
      Utility functions to look up, list, and execute the builtin applications.
    </p>
</ol>

<p>
  <b>Built-In Application Utility Functions</b>.
  The utility functions exported by the builtin application logic are prototyped in <code>nuttx/include/nuttx/binfmt/builtin.h</code> and <code>apps/include/builtin.h</code>.
  These utility functions include:
</p>

<ul>
  <li>
    <p>
      <code>int builtin_isavail(FAR const char *appname);</code>
      Checks for availability of application registered as <code>appname</code> during build time.
    </p>
  <li>
    <p>
      <code>const char *builtin_getname(int index);</code>
      Returns a pointer to a name of built-in application pointed by the <code>index</code>.
      This is the utility function that is used by NSH in order to list the available built-in applications when &quot;<code>nsh&gt; help</code>&quot; is entered.
    </p>
  <li>
    <p>
      <code>int exec_builtin(FAR const char *appname, FAR const char **argv);</code>
      Executes built-in builtin application registered during compile time.
      This is the utility function used by NSH to execute the built-in application.
    </p>
</ul>

<p>
  <b>Autogenerated Header Files</b>.
  Application entry points with their requirements are gathered together in two files when NuttX is first built:
</p>
<ol>
  <li>
    <p>
      <code>apps/builtin/builtin_proto.h</code>:
      Prototypes of application task entry points.
    </p>
  <li>
    <p>
      <code>apps/builtin/builtin_list.h</code>:
      Application specific information and start-up requirements
    </p>
</ol>

<p>
  <b>Registration of Built-In Applications</b>.
  The NuttX build occurs in several phases as different build targets are executed:
  (1) <i>context</i> when the configuration is established,
  (2) <i>depend </i>when target dependencies are generated, and
  (3) <i>default</i> (<code>all</code>) when the normal compilation and link operations are performed.
  Built-in application information is collected during the make <i>context</i> build phase.
</p>

<p>
  An example application that can be &quot;built-in&quot; is be found in the <code>apps/examples/hello directory</code>.
  Let's walk through this specific cause to illustrate the general way that built-in applications are created and how they register themselves so that they can be used from NSH.
</p>

<p>
  <code><b>apps/examples/hello</code></b>.
   The main routine for apps/examples/hello can be found in <code>apps/examples/hello/main.c</code>.
   The main routine is:
</p>
<ul><pre>
int hello_main(int argc, char *argv[])
{
  printf(&quot;Hello, World!!\n&quot;);
  return 0;
}
</pre></ul>

<p>
  This is the built in function that will be registered during the <i>context</i> build phase of the NuttX build.
  That registration is performed by logic in <code>apps/examples/hello/Makefile</code>.
  But the build system gets to that logic through a rather tortuous path:
</p>

<ol>
  <li>
    <p>
      The top-level context make target is in <code>nuttx/Makefile</code>.
      All build targets depend upon the <i>context</i> build target.
      For the <code>apps/</code> directory, this build target will execute the <i>context</i> target in the <code>apps/Makefile</code>.
    </p>
  <li>
    <p>
      The <code>apps/Makefile</code> will, in turn, execute the <i>context</i> targets in all of the configured sub-directories.
      In our case will include the <code>Makefile</code> in <code>apps/examples</code>.
    </p>
  <li>
    <p>
      And finally, the <code>apps/examples/Makefile</code> will execute the <i>context</i> target in all configured <code>example</code>sub-directores, getting us finally to <code>apps/examples/Makefile</code> which is covered below.</p>
</ol>

<p>
  <b>NOTE</b>:
  Since this context build phase can only be executed one time, any subsequent configuration changes that you make will, then, not be reflected in the build sequence.
  That is a common area of confusion.
  Before you can instantiate the new configuration, you have to first get rid of the old configuration.
  The most drastic way to this is:
</p>
<ul><pre>
make distclean
</pre></ul>
<p>
  But then you will have to re-configuration NuttX from scratch.
  But if you only want to re-build the configuration in the <code>apps/</code> sub-directory, then there is a less labor-intensive way to do that.
  The following NuttX make command will remove the configuration only from the <code>apps/</code> directory and will let you continue without re-configuring everything:
</p>
<ul><pre>
make apps_distclean
</pre></ul>

<p>
  Logic for the <code>context</code> target in <code>apps/examples/hello/Makefile</code> registers the <code>hello_main()</code> application in the <code>builtin</code>'s <code>builtin_proto.h</code>and <code>builtin_list.h</code> files.
  That logic that does that in  <code>apps/examples/hello/Makefile</code> is abstracted below:
</p>
<ol>
  <li>
    <p>
      First, the <code>Makefile</code> includes <code>apps/Make.defs</code>:
    </p>
<ul><pre>
include $(APPDIR)/Make.defs
</pre></ul>
    <p>
      This defines a macro called <code>REGISTER</code> that adds data to the <i>builtin</i> header files:
    </p>
<ul><pre>
define REGISTER
    @echo &quot;Register: $1&quot;
    @echo &quot;{ \&quot;$1\&quot;, $2, $3, $4 },&quot; &gt;&gt; &quot;$(APPDIR)/builtin/builtin_list.h&quot;
    @echo &quot;EXTERN int $4(int argc, char *argv[]);&quot; &gt;&gt; &quot;$(APPDIR)/builtin/builtin_proto.h&quot;
endef
</pre></ul>
    <p>
      When this macro runs, you will see the output in the build &quot;<code>Register: hello</code>&quot;, that is a sure sign that the registration was successful.
    </p>
  <li>
    <p>
      The make file then defines the application name (<code>hello</code>), the task priority (default), and the stack size that will be allocated in the task runs (2K).
    </p>
<ul><pre>
APPNAME         = hello
PRIORITY        = SCHED_PRIORITY_DEFAULT
STACKSIZE       = 2048
</pre></ul>

  <li>
    <p>
      And finally, the <code>Makefile</code> invokes the <code>REGISTER</code> macro to added the <code>hello_main()</code> builtin application.
      Then, when the system build completes, the <code>hello</code> command can be executed from the NSH command line.
      When the <code>hello</code> command is executed, it will start the task with entry point <code>hello_main()</code> with the default priority and with a stack size of 2K.
   </p>
<ul><pre>
context:
  $(call REGISTER,$(APPNAME),$(PRIORITY),$(STACKSIZE),$(APPNAME)_main)
</pre></ul>
</ol>

<p>
  <b>Other Uses of Built-In Application.</b>
  The primary purpose of builtin applications is to support command line execution of applications from NSH.
  However, there is one other use of builtin applications that should be mentioned.
</p>

<ol>
  <li>
    <p><b><i>binfs</i></b>.
    <i>binfs</i> is a tiny file system located at <code>apps/builtin/binfs.c</code>.
     This provides an alternative what of visualizing installed builtin applications.
     Without <i>binfs</i>, you can see the installed builtin applications using the NSH help command.
     <i>binfs</i> will create a tiny pseudo-file system mounted at <code>/bin</code>.
     Using <i>binfs</i>, you can see the available builtin applications by listing the contents of  <code>/bin</code> directory.
     This gives some superficial Unix compatibility, but does not really add any new functionality.
    </p>
  </li>
</ol>

<h3>4.3.2 Synchronous Built-In Applications</h3>

<p>
  By default, built-in commands started from the NSH command line will run asynchronously with NSH.
  If you want to force NSH to execute commands then wait for the command to execute, you can enable that feature by adding the following to the NuttX configuration file:
</p>
<ul><pre>
CONFIG_SCHED_WAITPID=y
</pre></ul>
<p>
  This configuration option enables support for the standard <code>waitpid()</code> RTOS interface.
  When that interface is enabled, NSH will use it to wait, sleeping until the built-in application executes to completion.
</p>
<p>
  Of course, even with <code>CONFIG_SCHED_WAITPID=y</code> defined, specific applications can still be forced to run asynchronously by adding the ampersand (&amp;) after the NSH command.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="custinit"><h2>4.4 Customizing NSH Initialization</h2></a>
  </td>
  </tr>
</table>

<p>
  <b>Ways to Customize NSH Initialization</b>.
  There are three ways to customize the NSH start-up behavior.
  Here they are presented in order of increasing difficulty:
</p>

<ol>
  <li>
    <p>
      You can extend the initialization logic in <code>configs/stm3240g-eval/src/stm32_appinit.c</code>.
      The logic there is called each time that NSH is started and is good place in particular for any device-related initialization.
    </p>
  <li>
    <p>
      You replace the sample code at <code>apps/examples/nsh/nsh_main.c</code> with whatever start-up logic that you want.
      NSH is a library at <code>apps/nshlib</code>.
      <code>apps.examplex/nsh</code> is just a tiny, example start-up function (<code>CONFIG_USER_ENTRYPOINT</code>()) that that runs immediately and illustrates how to start NSH
      If you want something else to run immediately then you can write your write your own custom <code>CONFIG_USER_ENTRYPOINT</code>() function and then start other tasks from your custom <code>CONFIG_USER_ENTRYPOINT</code>().
    </p>
  <li>
    <p>
      NSH also supports a start-up script that executed when NSH first runs.
      This mechanism has the advantage that the start-up script can contain any NSH commands and so can do a lot of work with very little coding.
      The disadvantage is that is is considerably more complex to create the start-up script.
      It is sufficiently complex that is deserves its own paragraph
  </p>
</ol>

<h3>4.4.1 NuttShell Start up Scripts</h3>

<p>
  First of all you should look at <a href="#startupscript">NSH Start-Up Script</a> paragraph.
  Most everything you need to know can be found there.
  That information will be repeated and extended here for completeness.
</p>

<p>
  <b>NSH Start-Up Script</b>.
  NSH supports options to provide a start up script for NSH.
  The start-up script contains any command support by NSH (i.e., that you see when you enter 'nsh&gt; help').
  In general this capability is enabled with <code>CONFIG_NSH_ROMFSETC=y</code>, but has several other related configuration options as described with the <a href="#nshconfiguration">NSH-specific configuration settings</a> paragraph.
  This capability also depends on:
</p>

<ul>
  <li>
    <p>
      <code>CONFIG_DISABLE_MOUNTPOINT=n</code>.
      If mount point support is disabled, then you cannot mount <i>any</i> file systems.
    </p>
  <li>
    <p>
      <code>CONFIG_NFILE_DESCRIPTORS &gt; 4</code>.
      Of course you have to have file descriptions to use any thing in the file system.
    </p>
  <li>
    <p>
      <code>CONFIG_FS_ROMFS</code> enabled.
      This option enables ROMFS file system support.
    </p>
</ul>

<p>
  <b>Default Start-Up Behavior</b>.
  The implementation that is provided is intended to provide great flexibility for the use of Start-Up files.
  This paragraph will discuss the general behavior when all of the configuration options are set to the default values.
</p>
<p>
 In this default case, enabling <code>CONFIG_NSH_ROMFSETC</code> will cause NSH to behave as follows at NSH start-up time:
</p>
<ul>
  <li>
    <p>
      NSH will create a read-only RAM disk (a ROM disk), containing a tiny ROMFS filesystem containing the following:
    </p>
<ul><pre>
`--init.d/
    `-- rcS
</pre></ul>
    <p>
      Where <code>rcS</code> is the NSH start-up script.
    </p>
  <li>
    <p>
      NSH will then mount the ROMFS filesystem at <code>/etc</code>, resulting in:
    </p>
<ul><pre>
|--dev/
|   `-- ram0
`--etc/
    `--init.d/
        `-- rcS</PRE>
</pre></ul>
  <li>
    <p>
      By default, the contents of <code>rcS</code> script are:
    </p>
<ul><pre>
# Create a RAMDISK and mount it at /tmp

mkrd -m 1 -s 512 1024
mkfatfs /dev/ram1
mount -t vfat /dev/ram1 /tmp
</pre></ul>
  <li>
    <p>
      NSH will execute the script at <code>/etc/init.d/rcS</code> at start-up (before the first NSH prompt).
      After execution of the script, the root FS will look like:
    </p>
<ul><pre>
|--dev/
|   |-- ram0
|   `-- ram1
|--etc/
|   `--init.d/
|       `-- rcS
`--tmp/
</pre></ul>
</ul>

<p>
  <b>Example Configurations</b>.
  Here are some configurations that have <code>CONFIG_NSH_ROMFSETC=y</code> in the NuttX configuration file.
  They might provide useful examples:
</p>
<ul>
  <code>configs/hymini-stm32v/nsh2<br>
  configs/ntosd-dm320/nsh<br>
  configs/sim/nsh<br>
  configs/sim/nsh2<br>
  configs/sim/nx<br>
  configs/sim/nx11<br>
  configs/sim/touchscreen<br>
</ul>
<p>
  In most of these cases, the configuration sets up the <i>default</i> <code>/etc/init.d/rcS</code> script.
  The default script is here: <code>apps/nshlib/rcS.template</code>.
  (The funny values in the template like <code>XXXMKRDMINORXXX</code> get replaced via <code>sed</code> at build time).
  This default configuration creates a ramdisk and mounts it at <code>/tmp</code> as discussed above.
</p>
<p>
  If that default behavior is not what you want, then you can provide your own custom <code>rcS</code> script by defining <code>CONFIG_NSH_ARCHROMFS=y</code> in the configuration file.
</p>
<p>
  <b>Modifying the ROMFS Image</b>.
  The contents of the <code>/etc</code> directory are retained in the file <code>apps/nshlib/nsh_romfsimg.h</code> OR, if <code>CONFIG_NSH_ARCHROMFS</code> is defined, <code>include/arch/board/nsh_romfsimg.h</code>.
  In order to modify the start-up behavior, there are three things to study:
</p>

<ol>
  <li>
    <p>
      <b>Configuration Options.</b>
      The additional <code>CONFIG_NSH_ROMFSETC</code> configuration options discussed with the other <a href="#nshconfiguration">NSH-specific configuration settings</a>.
    </p>
  <li>
    <p>
      <b><code>tools/mkromfsimg.sh</code> Script</b>.
      The script <code>tools/mkromfsimg.sh</code> creates <code>nsh_romfsimg.h</code>.
      It is not automatically executed.
      If you want to change the configuration settings associated with creating and mounting the <code>/tmp</code> directory, then it will be necessary to re-generate this header file using the <code>tools/mkromfsimg.sh</code> script.
    </p>
    <p>
      The behavior of this script depends upon several things:
    </p>
    <ol>
      <li>
        <p>
          The configuration  settings then installed configuration.
        </p>
      <li>
        <p>
          The <code>genromfs</code> tool(available from <a href="http://romfs.sourceforge.net/">http://romfs.sourceforge.net</a>) or included within the NuttX buildroot toolchain.
          There is also a snapshot available in the NuttX tools repository <a href="https://bitbucket.org/nuttx/tools/src/master/genromfs-0.5.2.tar.gz">here</a>.
        </p>
      <li>
        <p>
          The <code>xxd</code> tool that is used to generate the C header files (xxd is a normal part of a complete Linux or Cygwin installation, usually as part of the <code>vi</code> package).
        </p>
      <li>
        <p>
          The file <code>apps/nshlib/rcS.template</code> (OR, if <code>CONFIG_NSH_ARCHROMFS</code> is defined <code>include/arch/board/rcs.template</code>.
      </p>
    </ol>
  <li>
    <p>
      <code><b>rcS.template</b></code>.
      The file <code>apps/nshlib/rcS.template</code> contains the general form of the <code>rcS</code> file; configured values are plugged into this template file to produce the final <code>rcS</code> file.
    </p>
    <p>
       To generate a custom <code>rcS</code> file a copy of <code>rcS.template</code> needs to be placed at <code>tools/</code> and changed according to the desired start-up behaviour.
       Running <code>tools/mkromfsimg.h</code> creates <code>nsh_romfsimg.h</code> which needs to be copied to <code>apps/nhslib</code> OR if <code>CONFIG_NSH_ARCHROMFS</code> is defined to <code>configs/&lt;board&gt;/include</code>.
    </p>
</ol>

<p>
  <b><code>rcS.template</code></b>.
  The default <code>rcS.template</code>, </code><code>apps/nshlib/rcS.template</code>, generates the standard, default <code>apps/nshlib/nsh_romfsimg.h</code> file.
</p>

<p>
  If <code>CONFIG_NSH_ARCHROMFS</code> is defined in the NuttX configuration file, then a custom, board-specific <code>nsh_romfsimg.h</code> file residing in <code>configs/&lt;board&gt;/include</code>will be used.
  NOTE when the OS is configured, <code>include/arch/board</code> will be linked to <code>configs/&lt;board&gt;/include</code>.
</p>

<p>
  All of the startup-behavior is contained in <code>rcS.template</code>.
  The role of <code>mkromfsimg.sh</code> script is to (1) apply the specific configuration settings to <code>rcS.template</code> to create the final <code>rcS</code>, and (2) to generate the header file <code>nsh_romfsimg.h</code> containg the ROMFS file system image.
  To do this,  <code>mkromfsimg.sh</code> uses two tools that must be installed in your system:
</p>
<ol>
  <li>
    <p>
      The <code>genromfs</code> tool that is used to generate the ROMFS file system image.</code>
    </p>
  <li>
    <p>
      The <code>xxd</code> tool that is used to create the C header file.
    </p>
</ol>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="nshlogin"><h1>5.0 Shell Login</h1></a>
  </td>
  </tr>
</table>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="enablelogin"><h2>5.1 Enabling Shell Logins</h2></a>
  </td>
  </tr>
</table>
<p>
  NuttShell sessions can be protected by requiring that the user supply username and password credentials at the beginning of the session.
  Logins can be enabled for standard USB or serial consoles with:
</p>
<ul><pre>
CONFIG_NSH_CONSOLE_LOGIN=y
</pre></ul>
<p>
  Logins for Telnet sessions can be enabled separately with:
</p>
<ul><pre>
CONFIG_NSH_TELNET_LOGIN=y
</pre></ul>
<p>
  Logins can be enabled for either or both session types.
  On a successful login, the user will have access to the NSH session:
</p>
<ul><pre>
login: admin
password:
User Logged-in!

NuttShell (NSH)
nsh&gt;
</pre></ul>
<p>
  After each failed login attempt, a delay can be set up.
  The purpose of this delay is to discourage attempts to crack the password by brute force.
  That delay is configured with
</p>
<ul><pre>
CONFIG_NSH_LOGIN_FAILDELAY=0
</pre></ul>
<p>
  This setting provides the login failure delay in units of milliseconds.
  The system will pause this amount of time after each failed login attempt.
  After a certain number of failed login attempts, the session will be closed.
  That number is controlled by:
</p>
<ul><pre>
CONFIG_NSH_LOGIN_FAILCOUNT=3
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="verifymethods"><h2>5.2 Verification of Credentials</h2></a>
  </td>
  </tr>
</table>
<p>
  There are three ways that NSH can be configured to verify user credentials at login time:
</p>
<ol>
  <li>
    <p>
      The simplest implementation simply uses fixed login credentials and is selected with:
    </p>
<ul><pre>
CONFIG_NSH_LOGIN_FIXED=y
</pre></ul>
    <p>
      The fixed login credentials are selected via: 
    </p>
<ul><pre>
CONFIG_NSH_LOGIN_USERNAME=admin
CONFIG_NSH_LOGIN_PASSWORD=&quot;Administrator&quot;
</pre></ul>
    <p>
      This is not very flexible since there can be only one user and the password is fixed in the FLASH image. This option is also not very secure because a malicious user could get the password by just looking at the <code>.text</code> stings in the flash image.
    </p>
  </li>
  <li>
    <p>
      NSH can also be configured to defer the entire user credential verification to platform-specific logic with this setting:
    </p>
<ul><pre>
CONFIG_NSH_LOGIN_PLATFORM=y
</pre></ul>
    <p>
      In this case, NSH will call a platform-specific function to perform the verification of user credentials.
      The platform-specific logic must provide a function with the following prototype:
    </p>
<ul><pre>
int platform_user_verify(FAR const char *username, FAR const char *password);
</pre></ul>
     <p>
       which is prototyped an described in <code>apps/include/nsh.h</code> and which may be included like:
     </p>
<ul><pre>
#include &lt;apps/nsh.h&gt;
</pre></ul>
     <p>
        An appropriate place to implement this function might be in the directory <code>apps/platform/&lt;board&gt;</code>.
     </p>
   <li>
     <p>
       A final option is to use a password file contained encrypted password information.
       This final option is selected with the following and described in more detail in the
       following paragraph.
     </p>
<ul><pre>
CONFIG_NSH_LOGIN_PASSWD=y
</pre></ul>
   </li>
</ol>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="passwdfiles"><h2>5.3 Password Files</h2></a>
  </td>
  </tr>
</table>
<p>
  NuttX can also be configured to support a password file, by default at <code>/etc/passwd</code>.
  This option enables support for a password file:
</p>
<ul><pre>
CONFIG_NSH_LOGIN_PASSWD=y
</pre></ul>
<p>
This options requires that you have selected <code>CONFIG_FSUTILS_PASSWD=y</code> to enable the access methods of <code>apps/fsutils/passwd</code>:
</p>
<ul><pre>
CONFIG_FSUTILS_PASSWD=y
</pre></ul>
<p>
  And this determines the location of the password file in a mounted volume:
</p>
<ul><pre>
CONFIG_FSUTILS_PASSWD_PATH=&quot;/etc/passwd&quot;
</pre></ul>
<p>
  <code>/etc/passwd</code> is a <i>standard</i> location, but you will need to locate the password where ever you have a mounted volume.
</p>
<p>
  The password file can be a fixed list of users in a ROMFS file system or a modifiable list maintained in a file in some writable file system.  If the password file lies in a read-only file system like ROMFS, then you should also indicate that the password file is read-only.
</p>
<ul><pre>
CONFIG_FSUTILS_PASSWD_READONLY=y
</pre></ul>
<p>
  If the password file is writable, then additional NSH commands will be enabled to modify the password file:  <a href="#cmduseradd"><code>useradd</code></a>, <a href="#cmduserdel"><code>userdel</code></a>, and <a href="#cmdpasswd"><code>passwd</code></a>.  If you do not wish you have these commands available, then they should be specifically disabled.
</p>
<p>
  The password file logic requires a few additional settings:
<ol>
  <li>
    <p>
      The size of dynamically allocated and freed buffer that is used for file access:
    </p>
<ul><pre>
CONFIG_FSUTILS_PASSWD_IOBUFFER_SIZE=512
</pre></ul>
  </li>
  <li>
    <p>
      And the 128-bit encryption key.  The password file currently uses the Tiny Encryption Algorithm (TEA), but could be extended to use something more powerful.
    </p>
<ul><pre>
CONFIG_FSUTILS_PASSWD_KEY1=0x12345678
CONFIG_FSUTILS_PASSWD_KEY2=0x9abcdef0
CONFIG_FSUTILS_PASSWD_KEY3=0x12345678
CONFIG_FSUTILS_PASSWD_KEY4=0x9abcdef0
</pre></ul>
  </li>
</ol>
<p>
  Password can only be decrypted with access to this key.  Note that this key could potentially be fished out of your FLASH image, but without any symbolic information, that would be a difficult job since the TEA KEY is binary data and not distinguishable from other binary data in the FLASH image.
</p>
<p>
  If the password file is enabled (<code>CONFIG_NSH_LOGIN_PASSWD=y</code>), then the fixed user credentials will not be used for the NSH session login.  Instead, the password file will be consulted to verify the user credentials.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="passwdromfs"><h2>5.4 Creating a Password File for a ROMFS File System</h2></a>
  </td>
  </tr>
</table>
<p>
  What we want to accomplish is a ROMFS file system, mounted at <code>/etc</code> and containing the password file, <code>passwd</code> like:
</p>
<ul><pre>
NuttShell (NSH)
nsh&gt; ls -Rl /etc
/etc:
 dr-xr-xr-x       0 .
 dr-xr-xr-x       0 init.d/
 -r--r--r--      39 passwd
/etc/init.d:
 dr-xr-xr-x       0 ..
 -r--r--r--     110 rcS
nsh&gt;
</pre></ul>
<p>
  Where <code>/etc/init.d/rcS</code> is the start-up script; <code>/etc/passwd</code> is a the password file.  Note that here we assume that you are already using a start-up script.  We can then piggyback the passwd file into the <code>/etc</code> file system already mounted for the NSH start up file as described above <a href=#custinit>above</a>.
</p>
<p>
  I use the sim/nsh configuration to create a new password file, but other configurations could also be used.  That configuration already supports a ROMFS file system, passwords, and login prompts.  First, I make these changes to that configuration.
</p>
<ol>
  <li>
    <p>
      Disable logins
    </p>
<ul><pre>
- CONFIG_NSH_CONSOLE_LOGIN=y
+ # CONFIG_NSH_CONSOLE_LOGIN is not set
  # CONFIG_NSH_TELNET_LOGIN is not set
</pre></ul>
  </li>
  <li>
    <p>
      Move the password file to a write-able file system:
    </p>
<ul><pre>
- CONFIG_FSUTILS_PASSWD_PATH=&quot;/etc/passwd&quot;
+ CONFIG_FSUTILS_PASSWD_PATH=&quot;/tmp/passwd&quot;
</pre></ul>
  </li>
  <li>
    <p>
      Make the password file modifiable
    </p>
<ul><pre>
- CONFIG_FSUTILS_PASSWD_READONLY=y
# CONFIG_FSUTILS_PASSWD_READONLY is not set
</pre></ul>
  </li>
</ol>
<p>
  Now rebuild the simulation.  No login should be required to enter the
  shell and you should find the <a href="#cmduseradd"><code>useradd</code></a>, <a href="#cmduserdel"><code>userdel</code></a>, and <a href="#cmdpasswd"><code>passwd</code></a> commands available in the help summary, provided that they are enabled.
  Make certain that the <code>useradd</code> command is not disabled:
</p>
<ul><pre>
# CONFIG_NSH_DISABLE_USERADD is not set
</pre></ul>
<p>
  Use the NSH <a href="#cmduseradd"><code>useradd</code></a> command to add new uses with new user passwords like:
</p>
<ul><pre>
nsh&gt; useradd &lt;username&gt; &lt;password&gt;
</pre></ul>
<p>
  Do this as many times as you would like.  Each time that you do this a new
  entry with an encrypted password will be added to the <code>passwd</code> file at
  <code>/tmp/passwd</code>.  You can see the content of the password file like:
</p>
<ul><pre>
nsh&gt; cat /tmp/passwd
</pre></ul>
<p>
  When you are finished, you can simply copy the <code>/tmp/passwd</code> content from the
  <code>cat</code> command and paste it into an editor.  Make sure to remove any
  carriage returns that may have ended up on the file if you are using
  Windows.
</p>
<p>
  Then create/re-create the <code>nsh_romfsimg.h</code> file as described below.
</p>
<ol>
  <li>
    <p>
      The content on the <code>nsh_romfsimg.h</code> header file is generated from a template directory structure.  Create the directory structure:
    </p>
<ul><pre>
mkdir etc
mkdir etc/init.d
</pre></ul>
    <p>
       And copy your existing startup script into <code>etc/init.c</code> as <code>rcS</code>.
    </p>
  </li>
  <li>
    <p>
      Save your new password file in the <code>etc/</code> directory as <code>passwd</code>.
    </p>
  </li>
  <li>
    <p>
      Create the new ROMFS image.
    </p>
<ul><pre>
genromfs -f romfs_img -d etc -V MyVolName
</pre></ul>
  </li>
  <li>
    <p>
      Convert the ROMFS image to a C header file
    </p>
<ul><pre>
xxd -i romfs_img >nsh_romfsimg.h
</pre></ul>
  </li>
  <li>
    <p>
       Edit <code>nsh_romfsimg.h</code>: Mark both data definitions as <code>const</code> so that the data will be stored in FLASH.
    </p>
  </li>
  <li>
    <p>
      Edit nsh_romfsimg.h, mark both data definitions as <code>const</code> so that that will be stored in FLASH.
    </p>
  </li>
</ol>
<p>
  There is a good example of how to do this in the NSH simulation configuration at <a href="https://bitbucket.org/nuttx/nuttx/configs/src/master/sim/nsh/">configs/sim/nsh<a>.  The ROMFS support files are provided at <a href="https://bitbucket.org/nuttx/nuttx/configs/src/master/sim/include/">configs/sim/include<a> and the <a href="https://bitbucket.org/nuttx/nuttx/configs/src/master/sim/include/README.txt">README.txt</a> file at the location provides detailed information about creating and modifying the ROMFS file system.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="index"><h1>Index</h1></a>
  </td>
  </tr>
</table>

<table width="100%">
<tr><td width="33%" valign="top">
<ul>
  <li><a href="#builtinvars"><code>$?</code></a></li>
  <li><a href="#cmdtest"><code>[</code></a></li>
  <li><a href="#custoncmds">Adding NSH commands</a></li>
  <li><a href="#cmdaddroute"><code>addroute</code></a></li>
  <li><a href="#cmdarp"><code>arp</code></a></li>
  <li><a href="#custapps">Autogenerated header files</a></li>
  <li><a href="#cmdoverview">Background commands</a></li>
  <li><a href="#cmdoverview">Background command priority</a></li>
  <li><a href="#custapps"><code>binfs</code></a></li>
  <li><a href="#custonshlib"><code>board_app_initialize()</code></a></li>
  <li><a href="#cmdbreak"><code>break</code></a></li>
  <li><a href="#custapps">Built-In applications</a></li>
  <li><a href="#custapps">Built-In application start-up <code>main()</code></a></li>
  <li><a href="#builtinvars">Built-in variables</a></li>
  <li><a href="#custapps"><code>builtin_getname()</code></a></li>
  <li><a href="#custapps"><code>builtin_isavail()</code></a></li>
  <li><a href="#custapps"><code>builtin_list.h</code></a></li>
  <li><a href="#custapps"><code>builtin_proto.h</code></a></li>
  <li><a href="#cmdbase64dec"><code>base64dec</code></a></li>
  <li><a href="#cmdbase64enc"><code>base64enc</code></a></li>
  <li><a href="#cmdbasename"><code>basename</code></a></li>
  <li><a href="#cmdcat"><code>cat</code></a></li>
  <li><a href="#cmdcd"><code>cd</code></a></li>
  <li><a href="#cmdcmp"><code>cmp</code></a></li>
  <li><a href="#cle">Command Line Editing</a></li>
  <li><a href="#commands">Command summaries</a></li>
  <li><a href="#custoncmds">Command table</a></li>
  <li><a href="#conditional">Conditional command execution</a></li>
  <li><a href="#custinit"><code>CONFIG_DISABLE_MOUNTPOINT</code></a></li>
  <li><a href="#custinit"><code>CONFIG_FS_ROMFS</code></a></li>
  <li><a href="#custinit"><code>CONFIG_NFILE_DESCRIPTORS</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_ARCHINIT</code></a></li>
  <li><a href="#custinit"><code>CONFIG_NSH_ARCHROMFS</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_ARGCAT</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_BUILTIN_APPS</code></a></li>
  <li><a href="#custapps"><code>CONFIG_NSH_BUILTIN_APPS</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_CLE</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_CMDPARMS</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_CONSOLE</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_DHCPC</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_DISABLEBG</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_DISABLE_ITEF</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_DISABLE_LOOPS</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_DISABLESCRIPT</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_DISABLE_SEMICOLON</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_DRIPADDR</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_FATDEVNO</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_FATMOUNTPT</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_FATNSECTORS</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_FATSECTSIZE</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_FILEIOSIZE</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_INITSCRIPT</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_IOBUFFER_SIZE</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_IPADDR</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_LINELEN</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_MAX_ROUNDTRIP</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_NESTDEPTH</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_NETMASK</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_NOMAC</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_READLINE</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_ROMFSDEVNO</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_ROMFSETC</code></a></li>
  <li><a href="#custinit"><code>CONFIG_NSH_ROMFSETC</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_ARCHROMFS</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_ROMFSMOUNTPT</code></a></li>
</ul></td>
<td width="33%" valign="top">
<ul>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_ROMFSSECTSIZE</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_STRERROR</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_TELNET</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_TMPDIR</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_USBCONDEV</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_USBCONSOLE</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_UBSDEV_MINOR</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_USBDEV_TRACECLASS</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_USBDEV_TRACECONTROLLER</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_USBDEV_TRACEINIT</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_USBDEV_TRACEINTERRUPTS</code></a></li>
  <li><a href="#nshconfiguration"><code>CONFIG_NSH_USBDEV_TRACETRANSFERS</code></a></li>
  <li><a href="#custapps"><code>CONFIG_SCHED_WAITPID</code></a></li>
  <li><a href="#custapps"><code>CONFIGURED_APPS</code></a></li>
  <li><a href="#configuration">Configuration settings</a></li>
  <li><a href="#cmddependencies">Configuration settings, command dependencies</a></li>
  <li><a href="#nshconfiguration">Configuration settings, NSH-specific</a></li>
  <li><a href="#nshconsoles">consoles</a></li>
  <li><a href="#cmdcp"><code>cp</code></a></li>
  <li><a href="#currentwd">Current working directory</a></li>
  <li><a href="#customizingnsh">Customizing NSH</a></li>
  <li><a href="#custinit">Customizing NSH initialization</a></li>
  <li><a href="#cmddate"><code>date</code></a></li>
  <li><a href="#cmddd"><code>dd</code></a></li>
  <li><a href="#cmdaddroute"><code>delroute</code></a></li>
  <li><a href="#cmddf"><code>df</code></a></li>
  <li><a href="#cmddirname"><code>dirname</code></a></li>
  <li><a href="#looping"><code>do</code></a></li>
  <li><a href="#looping"><code>done</code></a></li>
  <li><a href="#cmdecho"><code>echo</code></a></li>
  <li><a href="#environvars">Environment Variables</a></li>
  <li><a href="#startupscript"><code>/etc/init.d/rcS</code></a>
  <li><a href="#cmdexec"><code>exec</code></a></li>
  <li><a href="#custapps"><code>exec_builtin()</code></a></li>
  <li><a href="#cmdexit"><code>exit</code></a></li>
  <li><a href="#cmdfree"><code>free</code></a></li>
  <li><a href="#custoncmds"><code>g_cmdmap</code></a></li>
  <li><a href="#custinit"><code>genromfs</code></a></li>
  <li><a href="#cmdget"><code>get</code></a></li>
  <li><a href="#nshprompt">Greeting</a></li>
  <li><a href="#cmdhelp"><code>help</code></a></li>
  <li><a href="#cmdhexdump"><code>hexdump</code></a></li>
  <li><a href="#conditional"><code>if-then[-else]-fi</code></a></li>
  <li><a href="#cmdifconfig"><code>ifconfig</code></a></li>
  <li><a href="#cmdifdown"><code>ifdown</code></a></li>
  <li><a href="#cmdifup"><code>ifup</code></a></li>
  <li><a href="#custonshlib">Initialization sequence</a></li>
  <li><a href="#cmdinsmod"><code>insmod</code></a></li>
  <li><a href="#cmdkill"><code>kill</code></a></li>
  <li><a href="#cmdlosetup"><code>losetup</code></a></li>
  <li><a href="#cmdls">ls</code></a></li>
  <li><a href="#cmdmbhw"><code>mb</code></a></li>
  <li><a href="#nshlogin">Login</a></li>
  <li><a href="#verifymethods">Login, Credentials</a></li>
  <li><a href="#cmdlsmod"><code>lsmod</code></a></li>
  <li><a href="#cmdmd5">md5</a></li>
  <li><a href="#cmdmbhw"><code>mh</code></a></li>
  <li><a href="#cmdmbhw"><code>mw</code></a></li>
  <li><a href="#cmdmkdir"><code>mkdir</code></a></li>
  <li><a href="#cmdmkfatfs"><code>mkfatfs</code></a></li>
  <li><a href="#cmdmkfifo"><code>mkfifo</code></a></li>
  <li><a href="#cmdmkrd"><code>mkrd</code></a></li>
  <li><a href="#custinit"><code>mkromfsimg.sh</code></a></li>
  <li><a href="#cmdmount"><code>mount</code></a></li>
</ul></td>
<td width="34%" valign="top">
<ul>
  <li><a href="#cmdmv"><code>mv</code></a></li>
  <li><a href="#cmdnfsmount"><code>nfsmount</code></a></li>
  <li><a href="#cmdoverview"><code>nice</code></a></li>
  <li><a href="#custonshlib">NSH library (<code>nshlib</code>)</a></li>
  <li><a href="#nshlibrary">NSH library (<code>nshlib</code>)</a></li>
  <li><a href="#custonshlib"><code>nsh_consolemain()</code></a></li>
  <li><a href="#custonshlib"><code>nsh_initialize()</code></a></li>
  <li><a href="#custonshlib"><code>nsh_main()</code></a></li>
  <li><a href="#custinit"><code>nsh_main.c</code></a></li>
  <li><a href="#custonshlib"><code>nsh_netinit()</code></a></li>
  <li><a href="#custoncmds"><code>nsh_output()</code></a></li>
  <li><a href="#custonshlib"><code>nsh_romfsetc()</code></a></li>
  <li><a href="#custonshlib"><code>nsh_telnetstart()</code></a></li>
  <li><a href="#custonshlib"><code>nshlib</code></a></li>
  <li><a href="#cmdnslookup"><code>nslookup</code></a></li>
  <li><a href="#environvars"><code>OLDPWD</code></a></li>
  <li><a href="#overview">Overview</a></li>
  <li><a href="#cmdpasswd"><code>passwd</code></a></li>
  <li><a href="#passwdfiles">Password File</a></li>
  <li><a href="#passwdromfs">Password File, ROMFS</a></li>
  <li><a href="#cmdping"><code>ping</code></a></li>
  <li><a href="#cmdping"><code>ping6</code></a></li>
  <li><a href="#cmdpoweroff"><code>poweroff</code></a></li>
  <li><a href="#nshprompt">Prompt</a></li>
  <li><a href="#cmdps"><code>ps</code></a></li>
  <li><a href="#cmdput"><code>put</code></a></li>
  <li><a href="#cmdpwd"><code>pwd</code></a></li>
  <li><a href="#environvars"><code>PWD</code></a></li>
  <li><a href="#custinit"><code>rcS.template</code></a></li>
  <li><a href="#cmdreboot"><code>reboot</code></a></li>
  <li><a href="#cmdoverview">Re-directed commands</a></li>
  <li><a href="#custapps">Registration of builtin applications</a></li>
  <li><a href="#cmdrm"><code>rm</code></a></li>
  <li><a href="#cmdrmdir"><code>rmdir</code></a></li>
  <li><a href="#cmdrmmod"><code>rmmod</code></a></li>
  <li><a href="#custinit">ROMFS, Modifying the ROMFS image</a></li>
  <li><a href="#passwdromfs">ROMFS, Password File</a></li>
  <li><a href="#cmdset"><code>set</code></a></li>
  <li><a href="#cmdsh"><code>sh</code></a></li>
  <li><a href="#cmdshutdown"><code>shutdown</code></a></li>
  <li><a href="#cmdoverview">Simple commands</a></li>
  <li><a href="#cmdsleep"><code>sleep</code></a></li>
  <li><a href="#custinit">Start-up, Default behavior</a></li>
  <li><a href="#startupscript">Start-up script</a>
  <li><a href="#custinit">Start-up script</a></li>
  <li><a href="#custinit"><code>stm32_appinit.c</code></a></li>
  <li><a href="#custapps">Synchronous built-in applications</a></li>
  <li><a href="#cmdtest"><code>test</code></a></li>
  <li><a href="#cmdtime"><code>time</code></a></li>
  <li><a href="#cmdunmount"><code>umount</code></a></li>
  <li><a href="#cmduname"><code>uname</code></a></li>
  <li><a href="#cmdunset"><code>unset</code></a></li>
  <li><a href="#looping"><code>until</code></a></li>
  <li><a href="#custonshlib"><code>up_cxxinitialize()</code></a></li>
  <li><a href="#cmdurldec"><code>urldecode</code></a></li>
  <li><a href="#cmdurlencode"><code>urlencode</code></a></li>
  <li><a href="#cmduseradd"><code>useradd</code></a></li>
  <li><a href="#cmduserdel"><code>userdel</code></a></li>
  <li><a href="#cmdusleep"><code>usleep</code></a></li>
  <li><a href="#custapps"><code>waitpid()</code></a></li>
  <li><a href="#cmdwget"><code>wget</code></a></li>
  <li><a href="#looping"><code>while</code></a></li>
  <li><a href="#cmdxd"><code>xd</code></a></li>
  <li><a href="#custinit"><code>xxd</code></a></li>
</ul></td>
</tr></table>

</body>
</html>
